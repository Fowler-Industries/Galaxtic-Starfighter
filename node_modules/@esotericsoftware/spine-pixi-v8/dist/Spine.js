/** ****************************************************************************
 * Spine Runtimes License Agreement
 * Last updated July 28, 2023. Replaces all prior versions.
 *
 * Copyright (c) 2013-2023, Esoteric Software LLC
 *
 * Integration of the Spine Runtimes into software or otherwise creating
 * derivative works of the Spine Runtimes is permitted under the terms and
 * conditions of Section 2 of the Spine Editor License Agreement:
 * http://esotericsoftware.com/spine-editor-license
 *
 * Otherwise, it is permitted to integrate the Spine Runtimes into software or
 * otherwise create derivative works of the Spine Runtimes (collectively,
 * "Products"), provided that each user of the Products must obtain their own
 * Spine Editor license and redistribution of the Products in any form must
 * include this license and copyright notice.
 *
 * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,
 * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE
 * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/
import { Assets, Cache, Container, fastCopy, Graphics, Texture, Ticker, ViewContainer, } from 'pixi.js';
import { AnimationState, AnimationStateData, AtlasAttachmentLoader, ClippingAttachment, Color, MeshAttachment, Physics, Pool, RegionAttachment, Skeleton, SkeletonBinary, SkeletonBounds, SkeletonClipping, SkeletonData, SkeletonJson, Skin, Vector2, } from '@esotericsoftware/spine-core';
;
const vectorAux = new Vector2();
Skeleton.yDown = true;
const clipper = new SkeletonClipping();
/** A bounds provider that provides a fixed size given by the user. */
export class AABBRectangleBoundsProvider {
    x;
    y;
    width;
    height;
    constructor(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }
    calculateBounds() {
        return { x: this.x, y: this.y, width: this.width, height: this.height };
    }
}
/** A bounds provider that calculates the bounding box from the setup pose. */
export class SetupPoseBoundsProvider {
    clipping;
    /**
     * @param clipping If true, clipping attachments are used to compute the bounds. False, by default.
     */
    constructor(clipping = false) {
        this.clipping = clipping;
    }
    calculateBounds(gameObject) {
        if (!gameObject.skeleton)
            return { x: 0, y: 0, width: 0, height: 0 };
        // Make a copy of animation state and skeleton as this might be called while
        // the skeleton in the GameObject has already been heavily modified. We can not
        // reconstruct that state.
        const skeleton = new Skeleton(gameObject.skeleton.data);
        skeleton.setToSetupPose();
        skeleton.updateWorldTransform(Physics.update);
        const bounds = skeleton.getBoundsRect(this.clipping ? new SkeletonClipping() : undefined);
        return bounds.width == Number.NEGATIVE_INFINITY
            ? { x: 0, y: 0, width: 0, height: 0 }
            : bounds;
    }
}
/** A bounds provider that calculates the bounding box by taking the maximumg bounding box for a combination of skins and specific animation. */
export class SkinsAndAnimationBoundsProvider {
    animation;
    skins;
    timeStep;
    clipping;
    /**
     * @param animation The animation to use for calculating the bounds. If null, the setup pose is used.
     * @param skins The skins to use for calculating the bounds. If empty, the default skin is used.
     * @param timeStep The time step to use for calculating the bounds. A smaller time step means more precision, but slower calculation.
     * @param clipping If true, clipping attachments are used to compute the bounds. False, by default.
     */
    constructor(animation, skins = [], timeStep = 0.05, clipping = false) {
        this.animation = animation;
        this.skins = skins;
        this.timeStep = timeStep;
        this.clipping = clipping;
    }
    calculateBounds(gameObject) {
        if (!gameObject.skeleton || !gameObject.state)
            return { x: 0, y: 0, width: 0, height: 0 };
        // Make a copy of animation state and skeleton as this might be called while
        // the skeleton in the GameObject has already been heavily modified. We can not
        // reconstruct that state.
        const animationState = new AnimationState(gameObject.state.data);
        const skeleton = new Skeleton(gameObject.skeleton.data);
        const clipper = this.clipping ? new SkeletonClipping() : undefined;
        const data = skeleton.data;
        if (this.skins.length > 0) {
            let customSkin = new Skin("custom-skin");
            for (const skinName of this.skins) {
                const skin = data.findSkin(skinName);
                if (skin == null)
                    continue;
                customSkin.addSkin(skin);
            }
            skeleton.setSkin(customSkin);
        }
        skeleton.setToSetupPose();
        const animation = this.animation != null ? data.findAnimation(this.animation) : null;
        if (animation == null) {
            skeleton.updateWorldTransform(Physics.update);
            const bounds = skeleton.getBoundsRect(clipper);
            return bounds.width == Number.NEGATIVE_INFINITY
                ? { x: 0, y: 0, width: 0, height: 0 }
                : bounds;
        }
        else {
            let minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY;
            animationState.clearTracks();
            animationState.setAnimationWith(0, animation, false);
            const steps = Math.max(animation.duration / this.timeStep, 1.0);
            for (let i = 0; i < steps; i++) {
                const delta = i > 0 ? this.timeStep : 0;
                animationState.update(delta);
                animationState.apply(skeleton);
                skeleton.update(delta);
                skeleton.updateWorldTransform(Physics.update);
                const bounds = skeleton.getBoundsRect(clipper);
                minX = Math.min(minX, bounds.x);
                minY = Math.min(minY, bounds.y);
                maxX = Math.max(maxX, bounds.x + bounds.width);
                maxY = Math.max(maxY, bounds.y + bounds.height);
            }
            const bounds = {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY,
            };
            return bounds.width == Number.NEGATIVE_INFINITY
                ? { x: 0, y: 0, width: 0, height: 0 }
                : bounds;
        }
    }
}
;
const maskPool = new Pool(() => new Graphics);
/**
 * The class to instantiate a {@link Spine} game object in Pixi.
 * The static method {@link Spine.from} should be used to instantiate a Spine game object.
 */
export class Spine extends ViewContainer {
    // Pixi properties
    batched = true;
    buildId = 0;
    renderPipeId = 'spine';
    _didSpineUpdate = false;
    beforeUpdateWorldTransforms = () => { };
    afterUpdateWorldTransforms = () => { };
    // Spine properties
    /** The skeleton for this Spine game object. */
    skeleton;
    /** The animation state for this Spine game object. */
    state;
    skeletonBounds;
    darkTint = false;
    _debug = undefined;
    _slotsObject = Object.create(null);
    clippingSlotToPixiMasks = Object.create(null);
    getSlotFromRef(slotRef) {
        let slot;
        if (typeof slotRef === 'number')
            slot = this.skeleton.slots[slotRef];
        else if (typeof slotRef === 'string')
            slot = this.skeleton.findSlot(slotRef);
        else
            slot = slotRef;
        if (!slot)
            throw new Error(`No slot found with the given slot reference: ${slotRef}`);
        return slot;
    }
    spineAttachmentsDirty = true;
    spineTexturesDirty = true;
    _lastAttachments = [];
    _stateChanged = true;
    attachmentCacheData = [];
    get debug() {
        return this._debug;
    }
    /** Pass a {@link SpineDebugRenderer} or create your own {@link ISpineDebugRenderer} to render bones, meshes, ...
     * @example spineGO.debug = new SpineDebugRenderer();
     */
    set debug(value) {
        if (this._debug) {
            this._debug.unregisterSpine(this);
        }
        if (value) {
            value.registerSpine(this);
        }
        this._debug = value;
    }
    _autoUpdate = true;
    get autoUpdate() {
        return this._autoUpdate;
    }
    /** When `true`, the Spine AnimationState and the Skeleton will be automatically updated using the {@link Ticker.shared} instance. */
    set autoUpdate(value) {
        if (value) {
            Ticker.shared.add(this.internalUpdate, this);
        }
        else {
            Ticker.shared.remove(this.internalUpdate, this);
        }
        this._autoUpdate = value;
    }
    _boundsProvider;
    /** The bounds provider to use. If undefined the bounds will be dynamic, calculated when requested and based on the current frame. */
    get boundsProvider() {
        return this._boundsProvider;
    }
    set boundsProvider(value) {
        this._boundsProvider = value;
        if (value) {
            this._boundsDirty = false;
        }
        this.updateBounds();
    }
    hasNeverUpdated = true;
    constructor(options) {
        if (options instanceof SkeletonData) {
            options = {
                skeletonData: options,
            };
        }
        super({});
        this.allowChildren = true;
        const skeletonData = options instanceof SkeletonData ? options : options.skeletonData;
        this.skeleton = new Skeleton(skeletonData);
        this.state = new AnimationState(new AnimationStateData(skeletonData));
        this.autoUpdate = options?.autoUpdate ?? true;
        // dark tint can be enabled by options, otherwise is enable if at least one slot has tint black
        this.darkTint = options?.darkTint === undefined
            ? this.skeleton.slots.some(slot => !!slot.data.darkColor)
            : options?.darkTint;
        const slots = this.skeleton.slots;
        for (let i = 0; i < slots.length; i++) {
            this.attachmentCacheData[i] = Object.create(null);
        }
        this._boundsProvider = options.boundsProvider;
    }
    /** If {@link Spine.autoUpdate} is `false`, this method allows to update the AnimationState and the Skeleton with the given delta. */
    update(dt) {
        this.internalUpdate(0, dt);
    }
    internalUpdate(_deltaFrame, deltaSeconds) {
        // Because reasons, pixi uses deltaFrames at 60fps.
        // We ignore the default deltaFrames and use the deltaSeconds from pixi ticker.
        this._updateAndApplyState(deltaSeconds ?? Ticker.shared.deltaMS / 1000);
    }
    get bounds() {
        if (this._boundsDirty) {
            this.updateBounds();
        }
        return this._bounds;
    }
    /**
     * Set the position of the bone given in input through a {@link IPointData}.
     * @param bone: the bone name or the bone instance to set the position
     * @param outPos: the new position of the bone.
     * @throws {Error}: if the given bone is not found in the skeleton, an error is thrown
     */
    setBonePosition(bone, position) {
        const boneAux = bone;
        if (typeof bone === 'string') {
            bone = this.skeleton.findBone(bone);
        }
        if (!bone)
            throw Error(`Cant set bone position, bone ${String(boneAux)} not found`);
        vectorAux.set(position.x, position.y);
        if (bone.parent) {
            const aux = bone.parent.worldToLocal(vectorAux);
            bone.x = aux.x;
            bone.y = -aux.y;
        }
        else {
            bone.x = vectorAux.x;
            bone.y = vectorAux.y;
        }
    }
    /**
     * Return the position of the bone given in input into an {@link IPointData}.
     * @param bone: the bone name or the bone instance to get the position from
     * @param outPos: an optional {@link IPointData} to use to return the bone position, rathern than instantiating a new object.
     * @returns {IPointData | undefined}: the position of the bone, or undefined if no matching bone is found in the skeleton
     */
    getBonePosition(bone, outPos) {
        const boneAux = bone;
        if (typeof bone === 'string') {
            bone = this.skeleton.findBone(bone);
        }
        if (!bone) {
            console.error(`Cant set bone position! Bone ${String(boneAux)} not found`);
            return outPos;
        }
        if (!outPos) {
            outPos = { x: 0, y: 0 };
        }
        outPos.x = bone.worldX;
        outPos.y = bone.worldY;
        return outPos;
    }
    /**
     * Advance the state and skeleton by the given time, then update slot objects too.
     * The container transform is not updated.
     *
     * @param time the time at which to set the state
     */
    _updateAndApplyState(time) {
        this.hasNeverUpdated = false;
        this.state.update(time);
        this.skeleton.update(time);
        const { skeleton } = this;
        this.state.apply(skeleton);
        this.beforeUpdateWorldTransforms(this);
        skeleton.updateWorldTransform(Physics.update);
        this.afterUpdateWorldTransforms(this);
        this.updateSlotObjects();
        this._stateChanged = true;
        this.onViewUpdate();
    }
    /**
     * - validates the attachments - to flag if the attachments have changed this state
     * - transforms the attachments - to update the vertices of the attachments based on the new positions
     * @internal
     */
    _validateAndTransformAttachments() {
        if (!this._stateChanged)
            return;
        this._stateChanged = false;
        this.validateAttachments();
        this.transformAttachments();
    }
    validateAttachments() {
        const currentDrawOrder = this.skeleton.drawOrder;
        const lastAttachments = this._lastAttachments;
        let index = 0;
        let spineAttachmentsDirty = false;
        for (let i = 0; i < currentDrawOrder.length; i++) {
            const slot = currentDrawOrder[i];
            const attachment = slot.getAttachment();
            if (attachment) {
                if (attachment !== lastAttachments[index]) {
                    spineAttachmentsDirty = true;
                    lastAttachments[index] = attachment;
                }
                index++;
            }
        }
        if (index !== lastAttachments.length) {
            spineAttachmentsDirty = true;
            lastAttachments.length = index;
        }
        this.spineAttachmentsDirty ||= spineAttachmentsDirty;
    }
    currentClippingSlot;
    updateAndSetPixiMask(slot, last) {
        // assign/create the currentClippingSlot
        const attachment = slot.attachment;
        if (attachment && attachment instanceof ClippingAttachment) {
            const clip = (this.clippingSlotToPixiMasks[slot.data.name] ||= { slot, vertices: new Array() });
            clip.maskComputed = false;
            this.currentClippingSlot = this.clippingSlotToPixiMasks[slot.data.name];
            return;
        }
        // assign the currentClippingSlot mask to the slot object
        let currentClippingSlot = this.currentClippingSlot;
        let slotObject = this._slotsObject[slot.data.name];
        if (currentClippingSlot && slotObject) {
            let slotClipping = currentClippingSlot.slot;
            let clippingAttachment = slotClipping.attachment;
            // create the pixi mask, only the first time and if the clipped slot is the first one clipped by this currentClippingSlot
            let mask = currentClippingSlot.mask;
            if (!mask) {
                mask = maskPool.obtain();
                currentClippingSlot.mask = mask;
                this.addChild(mask);
            }
            // compute the pixi mask polygon, if the clipped slot is the first one clipped by this currentClippingSlot
            if (!currentClippingSlot.maskComputed) {
                currentClippingSlot.maskComputed = true;
                const worldVerticesLength = clippingAttachment.worldVerticesLength;
                const vertices = currentClippingSlot.vertices;
                clippingAttachment.computeWorldVertices(slotClipping, 0, worldVerticesLength, vertices, 0, 2);
                mask.clear().poly(vertices).stroke({ width: 0 }).fill({ alpha: .25 });
            }
            slotObject.container.mask = mask;
        }
        else if (slotObject?.container.mask) {
            // remove the mask, if slot object has a mask, but currentClippingSlot is undefined
            slotObject.container.mask = null;
        }
        // if current slot is the ending one of the currentClippingSlot mask, set currentClippingSlot to undefined
        if (currentClippingSlot && currentClippingSlot.slot.attachment.endSlot == slot.data) {
            this.currentClippingSlot = undefined;
        }
        // clean up unused masks
        if (last) {
            for (const key in this.clippingSlotToPixiMasks) {
                const clippingSlotToPixiMask = this.clippingSlotToPixiMasks[key];
                if ((!(clippingSlotToPixiMask.slot.attachment instanceof ClippingAttachment) || !clippingSlotToPixiMask.maskComputed) && clippingSlotToPixiMask.mask) {
                    this.removeChild(clippingSlotToPixiMask.mask);
                    maskPool.free(clippingSlotToPixiMask.mask);
                    clippingSlotToPixiMask.mask = undefined;
                }
            }
            this.currentClippingSlot = undefined;
        }
    }
    transformAttachments() {
        const currentDrawOrder = this.skeleton.drawOrder;
        for (let i = 0; i < currentDrawOrder.length; i++) {
            const slot = currentDrawOrder[i];
            this.updateAndSetPixiMask(slot, i === currentDrawOrder.length - 1);
            const attachment = slot.getAttachment();
            if (attachment) {
                if (attachment instanceof MeshAttachment || attachment instanceof RegionAttachment) {
                    const cacheData = this._getCachedData(slot, attachment);
                    if (attachment instanceof RegionAttachment) {
                        attachment.computeWorldVertices(slot, cacheData.vertices, 0, 2);
                    }
                    else {
                        attachment.computeWorldVertices(slot, 0, attachment.worldVerticesLength, cacheData.vertices, 0, 2);
                    }
                    // sequences uvs are known only after computeWorldVertices is invoked
                    if (cacheData.uvs.length < attachment.uvs.length) {
                        cacheData.uvs = new Float32Array(attachment.uvs.length);
                    }
                    // need to copy because attachments uvs are shared among skeletons using the same atlas
                    fastCopy(attachment.uvs.buffer, cacheData.uvs.buffer);
                    const skeleton = slot.bone.skeleton;
                    const skeletonColor = skeleton.color;
                    const slotColor = slot.color;
                    const attachmentColor = attachment.color;
                    cacheData.color.set(skeletonColor.r * slotColor.r * attachmentColor.r, skeletonColor.g * slotColor.g * attachmentColor.g, skeletonColor.b * slotColor.b * attachmentColor.b, skeletonColor.a * slotColor.a * attachmentColor.a);
                    if (slot.darkColor) {
                        cacheData.darkColor.setFromColor(slot.darkColor);
                    }
                    cacheData.skipRender = cacheData.clipped = false;
                    const texture = attachment.region?.texture.texture || Texture.EMPTY;
                    if (cacheData.texture !== texture) {
                        cacheData.texture = texture;
                        this.spineTexturesDirty = true;
                    }
                    if (clipper.isClipping()) {
                        this.updateClippingData(cacheData);
                    }
                }
                else if (attachment instanceof ClippingAttachment) {
                    clipper.clipStart(slot, attachment);
                    continue;
                }
            }
            clipper.clipEndWithSlot(slot);
        }
        clipper.clipEnd();
    }
    updateClippingData(cacheData) {
        cacheData.clipped = true;
        clipper.clipTrianglesUnpacked(cacheData.vertices, cacheData.indices, cacheData.indices.length, cacheData.uvs);
        const { clippedVertices, clippedUVs, clippedTriangles } = clipper;
        const verticesCount = clippedVertices.length / 2;
        const indicesCount = clippedTriangles.length;
        if (!cacheData.clippedData) {
            cacheData.clippedData = {
                vertices: new Float32Array(verticesCount * 2),
                uvs: new Float32Array(verticesCount * 2),
                vertexCount: verticesCount,
                indices: new Uint16Array(indicesCount),
                indicesCount,
            };
            this.spineAttachmentsDirty = true;
        }
        const clippedData = cacheData.clippedData;
        const sizeChange = clippedData.vertexCount !== verticesCount || indicesCount !== clippedData.indicesCount;
        cacheData.skipRender = verticesCount === 0;
        if (sizeChange) {
            this.spineAttachmentsDirty = true;
            if (clippedData.vertexCount < verticesCount) {
                // buffer reuse!
                clippedData.vertices = new Float32Array(verticesCount * 2);
                clippedData.uvs = new Float32Array(verticesCount * 2);
            }
            if (clippedData.indices.length < indicesCount) {
                clippedData.indices = new Uint16Array(indicesCount);
            }
        }
        const { vertices, uvs, indices } = clippedData;
        for (let i = 0; i < verticesCount; i++) {
            vertices[i * 2] = clippedVertices[i * 2];
            vertices[(i * 2) + 1] = clippedVertices[(i * 2) + 1];
            uvs[i * 2] = clippedUVs[(i * 2)];
            uvs[(i * 2) + 1] = clippedUVs[(i * 2) + 1];
        }
        clippedData.vertexCount = verticesCount;
        for (let i = 0; i < indicesCount; i++) {
            if (indices[i] !== clippedTriangles[i]) {
                this.spineAttachmentsDirty = true;
                indices[i] = clippedTriangles[i];
            }
        }
        clippedData.indicesCount = indicesCount;
    }
    /**
     * ensure that attached containers map correctly to their slots
     * along with their position, rotation, scale, and visibility.
     */
    updateSlotObjects() {
        for (const i in this._slotsObject) {
            const slotAttachment = this._slotsObject[i];
            if (!slotAttachment)
                continue;
            this.updateSlotObject(slotAttachment);
        }
    }
    updateSlotObject(slotAttachment) {
        const { slot, container } = slotAttachment;
        const followAttachmentValue = slotAttachment.followAttachmentTimeline ? Boolean(slot.attachment) : true;
        container.visible = this.skeleton.drawOrder.includes(slot) && followAttachmentValue;
        if (container.visible) {
            let bone = slot.bone;
            container.position.set(bone.worldX, bone.worldY);
            container.angle = bone.getWorldRotationX();
            let cumulativeScaleX = 1;
            let cumulativeScaleY = 1;
            while (bone) {
                cumulativeScaleX *= bone.scaleX;
                cumulativeScaleY *= bone.scaleY;
                bone = bone.parent;
            }
            ;
            if (cumulativeScaleX < 0)
                container.angle -= 180;
            container.scale.set(slot.bone.getWorldScaleX() * Math.sign(cumulativeScaleX), slot.bone.getWorldScaleY() * Math.sign(cumulativeScaleY));
            container.alpha = this.skeleton.color.a * slot.color.a;
        }
    }
    /** @internal */
    _getCachedData(slot, attachment) {
        return this.attachmentCacheData[slot.data.index][attachment.name] || this.initCachedData(slot, attachment);
    }
    initCachedData(slot, attachment) {
        let vertices;
        if (attachment instanceof RegionAttachment) {
            vertices = new Float32Array(8);
            this.attachmentCacheData[slot.data.index][attachment.name] = {
                id: `${slot.data.index}-${attachment.name}`,
                vertices,
                clipped: false,
                indices: [0, 1, 2, 0, 2, 3],
                uvs: new Float32Array(attachment.uvs.length),
                color: new Color(1, 1, 1, 1),
                darkColor: new Color(0, 0, 0, 0),
                darkTint: this.darkTint,
                skipRender: false,
                texture: attachment.region?.texture.texture,
            };
        }
        else {
            vertices = new Float32Array(attachment.worldVerticesLength);
            this.attachmentCacheData[slot.data.index][attachment.name] = {
                id: `${slot.data.index}-${attachment.name}`,
                vertices,
                clipped: false,
                indices: attachment.triangles,
                uvs: new Float32Array(attachment.uvs.length),
                color: new Color(1, 1, 1, 1),
                darkColor: new Color(0, 0, 0, 0),
                darkTint: this.darkTint,
                skipRender: false,
                texture: attachment.region?.texture.texture,
            };
        }
        return this.attachmentCacheData[slot.data.index][attachment.name];
    }
    onViewUpdate() {
        // increment from the 12th bit!
        this._didViewChangeTick++;
        if (!this._boundsProvider) {
            this._boundsDirty = true;
        }
        if (this.didViewUpdate)
            return;
        this.didViewUpdate = true;
        const renderGroup = this.renderGroup || this.parentRenderGroup;
        if (renderGroup) {
            renderGroup.onChildViewUpdate(this);
        }
        this.debug?.renderDebug(this);
    }
    /**
     * Attaches a PixiJS container to a specified slot. This will map the world transform of the slots bone
     * to the attached container. A container can only be attached to one slot at a time.
     *
     * @param container - The container to attach to the slot
     * @param slotRef - The slot id or  slot to attach to
     * @param options - Optional settings for the attachment.
     * @param options.followAttachmentTimeline - If true, the attachment will follow the slot's attachment timeline.
     */
    addSlotObject(slot, container, options) {
        slot = this.getSlotFromRef(slot);
        // need to check in on the container too...
        for (const i in this._slotsObject) {
            if (this._slotsObject[i]?.container === container) {
                this.removeSlotObject(this._slotsObject[i].slot);
            }
        }
        this.removeSlotObject(slot);
        container.includeInBuild = false;
        // TODO only add once??
        this.addChild(container);
        const slotObject = {
            container,
            slot,
            followAttachmentTimeline: options?.followAttachmentTimeline || false,
        };
        this._slotsObject[slot.data.name] = slotObject;
        this.updateSlotObject(slotObject);
    }
    /**
     * Removes a PixiJS container from the slot it is attached to.
     *
     * @param container - The container to detach from the slot
     * @param slotOrContainer - The container, slot id or slot to detach from
     */
    removeSlotObject(slotOrContainer) {
        let containerToRemove;
        if (slotOrContainer instanceof Container) {
            for (const i in this._slotsObject) {
                if (this._slotsObject[i]?.container === slotOrContainer) {
                    this._slotsObject[i] = null;
                    containerToRemove = slotOrContainer;
                    break;
                }
            }
        }
        else {
            const slot = this.getSlotFromRef(slotOrContainer);
            containerToRemove = this._slotsObject[slot.data.name]?.container;
            this._slotsObject[slot.data.name] = null;
        }
        if (containerToRemove) {
            this.removeChild(containerToRemove);
            containerToRemove.includeInBuild = true;
        }
    }
    /**
     * Removes all PixiJS containers attached to any slot.
     */
    removeSlotObjects() {
        Object.entries(this._slotsObject).forEach(([slotName, slotObject]) => {
            if (slotObject)
                slotObject.container.removeFromParent();
            delete this._slotsObject[slotName];
        });
    }
    /**
     * Returns a container attached to a slot, or undefined if no container is attached.
     *
     * @param slotRef - The slot id or slot to get the attachment from
     * @returns - The container attached to the slot
     */
    getSlotObject(slot) {
        slot = this.getSlotFromRef(slot);
        return this._slotsObject[slot.data.name]?.container;
    }
    updateBounds() {
        this._boundsDirty = false;
        this.skeletonBounds ||= new SkeletonBounds();
        const skeletonBounds = this.skeletonBounds;
        skeletonBounds.update(this.skeleton, true);
        if (this._boundsProvider) {
            const boundsSpine = this._boundsProvider.calculateBounds(this);
            const bounds = this._bounds;
            bounds.clear();
            bounds.x = boundsSpine.x;
            bounds.y = boundsSpine.y;
            bounds.width = boundsSpine.width;
            bounds.height = boundsSpine.height;
        }
        else if (skeletonBounds.minX === Infinity) {
            if (this.hasNeverUpdated) {
                this._updateAndApplyState(0);
                this._boundsDirty = false;
            }
            this._validateAndTransformAttachments();
            const drawOrder = this.skeleton.drawOrder;
            const bounds = this._bounds;
            bounds.clear();
            for (let i = 0; i < drawOrder.length; i++) {
                const slot = drawOrder[i];
                const attachment = slot.getAttachment();
                if (attachment && (attachment instanceof RegionAttachment || attachment instanceof MeshAttachment)) {
                    const cacheData = this._getCachedData(slot, attachment);
                    bounds.addVertexData(cacheData.vertices, 0, cacheData.vertices.length);
                }
            }
        }
        else {
            this._bounds.minX = skeletonBounds.minX;
            this._bounds.minY = skeletonBounds.minY;
            this._bounds.maxX = skeletonBounds.maxX;
            this._bounds.maxY = skeletonBounds.maxY;
        }
    }
    /** @internal */
    addBounds(bounds) {
        bounds.addBounds(this.bounds);
    }
    /**
     * Destroys this sprite renderable and optionally its texture.
     * @param options - Options parameter. A boolean will act as if all options
     *  have been set to that value
     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well
     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well
     */
    destroy(options = false) {
        super.destroy(options);
        Ticker.shared.remove(this.internalUpdate, this);
        this.state.clearListeners();
        this.debug = undefined;
        this.skeleton = null;
        this.state = null;
        this._slotsObject = null;
        this._lastAttachments.length = 0;
        this.attachmentCacheData = null;
    }
    /** Converts a point from the skeleton coordinate system to the Pixi world coordinate system. */
    skeletonToPixiWorldCoordinates(point) {
        this.worldTransform.apply(point, point);
    }
    /** Converts a point from the Pixi world coordinate system to the skeleton coordinate system. */
    pixiWorldCoordinatesToSkeleton(point) {
        this.worldTransform.applyInverse(point, point);
    }
    /** Converts a point from the Pixi world coordinate system to the bone's local coordinate system. */
    pixiWorldCoordinatesToBone(point, bone) {
        this.pixiWorldCoordinatesToSkeleton(point);
        if (bone.parent) {
            bone.parent.worldToLocal(point);
        }
        else {
            bone.worldToLocal(point);
        }
    }
    /**
     * Use this method to instantiate a Spine game object.
     * Before instantiating a Spine game object, the skeleton (`.skel` or `.json`) and the atlas text files must be loaded into the Assets. For example:
     * ```
     * PIXI.Assets.add("sackData", "/assets/sack-pro.skel");
     * PIXI.Assets.add("sackAtlas", "/assets/sack-pma.atlas");
     * await PIXI.Assets.load(["sackData", "sackAtlas"]);
     * ```
     * Once a Spine game object is created, its skeleton data is cached into {@link Cache} using the key:
     * `${skeletonAssetName}-${atlasAssetName}-${options?.scale ?? 1}`
     *
     * @param options - Options to configure the Spine game object. See {@link SpineFromOptions}
     * @returns {Spine} The Spine game object instantiated
     */
    static from({ skeleton, atlas, scale = 1, darkTint, autoUpdate = true, boundsProvider }) {
        const cacheKey = `${skeleton}-${atlas}-${scale}`;
        if (Cache.has(cacheKey)) {
            return new Spine({
                skeletonData: Cache.get(cacheKey),
                darkTint,
                autoUpdate,
                boundsProvider,
            });
        }
        const skeletonAsset = Assets.get(skeleton);
        const atlasAsset = Assets.get(atlas);
        const attachmentLoader = new AtlasAttachmentLoader(atlasAsset);
        const parser = skeletonAsset instanceof Uint8Array
            ? new SkeletonBinary(attachmentLoader)
            : new SkeletonJson(attachmentLoader);
        parser.scale = scale;
        const skeletonData = parser.readSkeletonData(skeletonAsset);
        Cache.set(cacheKey, skeletonData);
        return new Spine({
            skeletonData,
            darkTint,
            autoUpdate,
            boundsProvider,
        });
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3BpbmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvU3BpbmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsrRUEyQitFO0FBRS9FLE9BQU8sRUFDTixNQUFNLEVBRU4sS0FBSyxFQUNMLFNBQVMsRUFHVCxRQUFRLEVBQ1IsUUFBUSxFQUVSLE9BQU8sRUFDUCxNQUFNLEVBQ04sYUFBYSxHQUNiLE1BQU0sU0FBUyxDQUFDO0FBRWpCLE9BQU8sRUFDTixjQUFjLEVBQ2Qsa0JBQWtCLEVBQ2xCLHFCQUFxQixFQUdyQixrQkFBa0IsRUFDbEIsS0FBSyxFQUNMLGNBQWMsRUFDZCxPQUFPLEVBQ1AsSUFBSSxFQUNKLGdCQUFnQixFQUNoQixRQUFRLEVBQ1IsY0FBYyxFQUNkLGNBQWMsRUFDZCxnQkFBZ0IsRUFDaEIsWUFBWSxFQUNaLFlBQVksRUFDWixJQUFJLEVBSUosT0FBTyxHQUNQLE1BQU0sOEJBQThCLENBQUM7QUEyQnJDLENBQUM7QUFFRixNQUFNLFNBQVMsR0FBRyxJQUFJLE9BQU8sRUFBRSxDQUFDO0FBRWhDLFFBQVEsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO0FBRXRCLE1BQU0sT0FBTyxHQUFHLElBQUksZ0JBQWdCLEVBQUUsQ0FBQztBQWF2QyxzRUFBc0U7QUFDdEUsTUFBTSxPQUFPLDJCQUEyQjtJQUU5QjtJQUNBO0lBQ0E7SUFDQTtJQUpULFlBQ1MsQ0FBUyxFQUNULENBQVMsRUFDVCxLQUFhLEVBQ2IsTUFBYztRQUhkLE1BQUMsR0FBRCxDQUFDLENBQVE7UUFDVCxNQUFDLEdBQUQsQ0FBQyxDQUFRO1FBQ1QsVUFBSyxHQUFMLEtBQUssQ0FBUTtRQUNiLFdBQU0sR0FBTixNQUFNLENBQVE7SUFDbkIsQ0FBQztJQUNMLGVBQWU7UUFDZCxPQUFPLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsS0FB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QUFJLEVBQUUsY0FBYyxFQUFvQjtRQUN6RyxNQUFNLFFBQVEsR0FBRyxHQUFHLFFBQVEsSUFBSSxLQUFLLElBQUksS0FBSyxFQUFFLENBQUM7UUFFakQsSUFBSSxLQUFLLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUM7WUFDekIsT0FBTyxJQUFJLEtBQUssQ0FBQztnQkFDaEIsWUFBWSxFQUFFLEtBQUssQ0FBQyxHQUFHLENBQWUsUUFBUSxDQUFDO2dCQUMvQyxRQUFRO2dCQUNSLFVBQVU7Z0JBQ1YsY0FBYzthQUNkLENBQUMsQ0FBQztRQUNKLENBQUM7UUFFRCxNQUFNLGFBQWEsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFtQixRQUFRLENBQUMsQ0FBQztRQUU3RCxNQUFNLFVBQVUsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFlLEtBQUssQ0FBQyxDQUFDO1FBQ25ELE1BQU0sZ0JBQWdCLEdBQUcsSUFBSSxxQkFBcUIsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUMvRCxNQUFNLE1BQU0sR0FBRyxhQUFhLFlBQVksVUFBVTtZQUNqRCxDQUFDLENBQUMsSUFBSSxjQUFjLENBQUMsZ0JBQWdCLENBQUM7WUFDdEMsQ0FBQyxDQUFDLElBQUksWUFBWSxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFFdEMsTUFBTSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDckIsTUFBTSxZQUFZLEdBQUcsTUFBTSxDQUFDLGdCQUFnQixDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBRTVELEtBQUssQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFLFlBQVksQ0FBQyxDQUFDO1FBRWxDLE9BQU8sSUFBSSxLQUFLLENBQUM7WUFDaEIsWUFBWTtZQUNaLFFBQVE7WUFDUixVQUFVO1lBQ1YsY0FBYztTQUNkLENBQUMsQ0FBQztJQUNKLENBQUM7Q0FDRCIsInNvdXJjZXNDb250ZW50IjpbIi8qKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBTcGluZSBSdW50aW1lcyBMaWNlbnNlIEFncmVlbWVudFxuICogTGFzdCB1cGRhdGVkIEp1bHkgMjgsIDIwMjMuIFJlcGxhY2VzIGFsbCBwcmlvciB2ZXJzaW9ucy5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAyMywgRXNvdGVyaWMgU29mdHdhcmUgTExDXG4gKlxuICogSW50ZWdyYXRpb24gb2YgdGhlIFNwaW5lIFJ1bnRpbWVzIGludG8gc29mdHdhcmUgb3Igb3RoZXJ3aXNlIGNyZWF0aW5nXG4gKiBkZXJpdmF0aXZlIHdvcmtzIG9mIHRoZSBTcGluZSBSdW50aW1lcyBpcyBwZXJtaXR0ZWQgdW5kZXIgdGhlIHRlcm1zIGFuZFxuICogY29uZGl0aW9ucyBvZiBTZWN0aW9uIDIgb2YgdGhlIFNwaW5lIEVkaXRvciBMaWNlbnNlIEFncmVlbWVudDpcbiAqIGh0dHA6Ly9lc290ZXJpY3NvZnR3YXJlLmNvbS9zcGluZS1lZGl0b3ItbGljZW5zZVxuICpcbiAqIE90aGVyd2lzZSwgaXQgaXMgcGVybWl0dGVkIHRvIGludGVncmF0ZSB0aGUgU3BpbmUgUnVudGltZXMgaW50byBzb2Z0d2FyZSBvclxuICogb3RoZXJ3aXNlIGNyZWF0ZSBkZXJpdmF0aXZlIHdvcmtzIG9mIHRoZSBTcGluZSBSdW50aW1lcyAoY29sbGVjdGl2ZWx5LFxuICogXCJQcm9kdWN0c1wiKSwgcHJvdmlkZWQgdGhhdCBlYWNoIHVzZXIgb2YgdGhlIFByb2R1Y3RzIG11c3Qgb2J0YWluIHRoZWlyIG93blxuICogU3BpbmUgRWRpdG9yIGxpY2Vuc2UgYW5kIHJlZGlzdHJpYnV0aW9uIG9mIHRoZSBQcm9kdWN0cyBpbiBhbnkgZm9ybSBtdXN0XG4gKiBpbmNsdWRlIHRoaXMgbGljZW5zZSBhbmQgY29weXJpZ2h0IG5vdGljZS5cbiAqXG4gKiBUSEUgU1BJTkUgUlVOVElNRVMgQVJFIFBST1ZJREVEIEJZIEVTT1RFUklDIFNPRlRXQVJFIExMQyBcIkFTIElTXCIgQU5EIEFOWVxuICogRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuICogV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuICogRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgRVNPVEVSSUMgU09GVFdBUkUgTExDIEJFIExJQUJMRSBGT1IgQU5ZXG4gKiBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICogKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTLFxuICogQlVTSU5FU1MgSU5URVJSVVBUSU9OLCBPUiBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUykgSE9XRVZFUiBDQVVTRUQgQU5EXG4gKiBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICogKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRIRVxuICogU1BJTkUgUlVOVElNRVMsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbmltcG9ydCB7XG5cdEFzc2V0cyxcblx0Qm91bmRzLFxuXHRDYWNoZSxcblx0Q29udGFpbmVyLFxuXHRDb250YWluZXJPcHRpb25zLFxuXHREZXN0cm95T3B0aW9ucyxcblx0ZmFzdENvcHksXG5cdEdyYXBoaWNzLFxuXHRQb2ludERhdGEsXG5cdFRleHR1cmUsXG5cdFRpY2tlcixcblx0Vmlld0NvbnRhaW5lcixcbn0gZnJvbSAncGl4aS5qcyc7XG5pbXBvcnQgeyBJU3BpbmVEZWJ1Z1JlbmRlcmVyIH0gZnJvbSAnLi9TcGluZURlYnVnUmVuZGVyZXIuanMnO1xuaW1wb3J0IHtcblx0QW5pbWF0aW9uU3RhdGUsXG5cdEFuaW1hdGlvblN0YXRlRGF0YSxcblx0QXRsYXNBdHRhY2htZW50TG9hZGVyLFxuXHRBdHRhY2htZW50LFxuXHRCb25lLFxuXHRDbGlwcGluZ0F0dGFjaG1lbnQsXG5cdENvbG9yLFxuXHRNZXNoQXR0YWNobWVudCxcblx0UGh5c2ljcyxcblx0UG9vbCxcblx0UmVnaW9uQXR0YWNobWVudCxcblx0U2tlbGV0b24sXG5cdFNrZWxldG9uQmluYXJ5LFxuXHRTa2VsZXRvbkJvdW5kcyxcblx0U2tlbGV0b25DbGlwcGluZyxcblx0U2tlbGV0b25EYXRhLFxuXHRTa2VsZXRvbkpzb24sXG5cdFNraW4sXG5cdFNsb3QsXG5cdHR5cGUgVGV4dHVyZUF0bGFzLFxuXHRUcmFja0VudHJ5LFxuXHRWZWN0b3IyLFxufSBmcm9tICdAZXNvdGVyaWNzb2Z0d2FyZS9zcGluZS1jb3JlJztcblxuLyoqXG4gKiBPcHRpb25zIHRvIGNyZWF0ZSBhIHtAbGluayBTcGluZX0gdXNpbmcge0BsaW5rIFNwaW5lLmZyb219LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNwaW5lRnJvbU9wdGlvbnMge1xuXHQvKiogdGhlIGFzc2V0IG5hbWUgZm9yIHRoZSBza2VsZXRvbiBgLnNrZWxgIG9yIGAuanNvbmAgZmlsZSBwcmV2aW91c2x5IGxvYWRlZCBpbnRvIHRoZSBBc3NldHMgKi9cblx0c2tlbGV0b246IHN0cmluZztcblxuXHQvKiogdGhlIGFzc2V0IG5hbWUgZm9yIHRoZSBhdGxhcyBmaWxlIHByZXZpb3VzbHkgbG9hZGVkIGludG8gdGhlIEFzc2V0cyAqL1xuXHRhdGxhczogc3RyaW5nO1xuXG5cdC8qKiAgVGhlIHZhbHVlIHBhc3NlZCB0byB0aGUgc2tlbGV0b24gcmVhZGVyLiBJZiBvbWl0dGVkLCAxIGlzIHBhc3NlZC4gU2VlIHtAbGluayBTa2VsZXRvbkJpbmFyeS5zY2FsZX0gZm9yIGRldGFpbHMuICovXG5cdHNjYWxlPzogbnVtYmVyO1xuXG5cdC8qKiAgU2V0IHRoZSB7QGxpbmsgU3BpbmUuYXV0b1VwZGF0ZX0gdmFsdWUuIElmIG9taXR0ZWQsIGl0IGlzIHNldCB0byBgdHJ1ZWAuICovXG5cdGF1dG9VcGRhdGU/OiBib29sZWFuO1xuXG5cdC8qKlxuXHQgKiBJZiBgdHJ1ZWAsIHVzZSB0aGUgZGFyayB0aW50IHJlbmRlcmVyIHRvIHJlbmRlciB0aGUgc2tlbGV0b25cblx0ICogSWYgYGZhbHNlYCwgdXNlIHRoZSBkZWZhdWx0IHBpeGkgcmVuZGVyZXIgdG8gcmVuZGVyIHRoZSBza2VsZXRvblxuXHQgKiBJZiBgdW5kZWZpbmVkYCwgdXNlIHRoZSBkYXJrIHRpbnQgcmVuZGVyZXIgaWYgYXQgbGVhc3Qgb25lIHNsb3QgaGFzIHRpbnQgYmxhY2tcblx0ICovXG5cdGRhcmtUaW50PzogYm9vbGVhbjtcblxuXHQvKiogVGhlIGJvdW5kcyBwcm92aWRlciB0byB1c2UuIElmIHVuZGVmaW5lZCB0aGUgYm91bmRzIHdpbGwgYmUgZHluYW1pYywgY2FsY3VsYXRlZCB3aGVuIHJlcXVlc3RlZCBhbmQgYmFzZWQgb24gdGhlIGN1cnJlbnQgZnJhbWUuICovXG5cdGJvdW5kc1Byb3ZpZGVyPzogU3BpbmVCb3VuZHNQcm92aWRlcixcbn07XG5cbmNvbnN0IHZlY3RvckF1eCA9IG5ldyBWZWN0b3IyKCk7XG5cblNrZWxldG9uLnlEb3duID0gdHJ1ZTtcblxuY29uc3QgY2xpcHBlciA9IG5ldyBTa2VsZXRvbkNsaXBwaW5nKCk7XG5cbi8qKiBBIGJvdW5kcyBwcm92aWRlciBjYWxjdWxhdGVzIHRoZSBib3VuZGluZyBib3ggZm9yIGEgc2tlbGV0b24sIHdoaWNoIGlzIHRoZW4gYXNzaWduZWQgYXMgdGhlIHNpemUgb2YgdGhlIFNwaW5lR2FtZU9iamVjdC4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU3BpbmVCb3VuZHNQcm92aWRlciB7XG5cdC8qKiBSZXR1cm5zIHRoZSBib3VuZGluZyBib3ggZm9yIHRoZSBza2VsZXRvbiwgaW4gc2tlbGV0b24gc3BhY2UuICovXG5cdGNhbGN1bGF0ZUJvdW5kcyAoZ2FtZU9iamVjdDogU3BpbmUpOiB7XG5cdFx0eDogbnVtYmVyO1xuXHRcdHk6IG51bWJlcjtcblx0XHR3aWR0aDogbnVtYmVyO1xuXHRcdGhlaWdodDogbnVtYmVyO1xuXHR9O1xufVxuXG4vKiogQSBib3VuZHMgcHJvdmlkZXIgdGhhdCBwcm92aWRlcyBhIGZpeGVkIHNpemUgZ2l2ZW4gYnkgdGhlIHVzZXIuICovXG5leHBvcnQgY2xhc3MgQUFCQlJlY3RhbmdsZUJvdW5kc1Byb3ZpZGVyIGltcGxlbWVudHMgU3BpbmVCb3VuZHNQcm92aWRlciB7XG5cdGNvbnN0cnVjdG9yIChcblx0XHRwcml2YXRlIHg6IG51bWJlcixcblx0XHRwcml2YXRlIHk6IG51bWJlcixcblx0XHRwcml2YXRlIHdpZHRoOiBudW1iZXIsXG5cdFx0cHJpdmF0ZSBoZWlnaHQ6IG51bWJlcixcblx0KSB7IH1cblx0Y2FsY3VsYXRlQm91bmRzICgpIHtcblx0XHRyZXR1cm4geyB4OiB0aGlzLngsIHk6IHRoaXMueSwgd2lkdGg6IHRoaXMud2lkdGgsIGhlaWdodDogdGhpcy5oZWlnaHQgfTtcblx0fVxufVxuXG4vKiogQSBib3VuZHMgcHJvdmlkZXIgdGhhdCBjYWxjdWxhdGVzIHRoZSBib3VuZGluZyBib3ggZnJvbSB0aGUgc2V0dXAgcG9zZS4gKi9cbmV4cG9ydCBjbGFzcyBTZXR1cFBvc2VCb3VuZHNQcm92aWRlciBpbXBsZW1lbnRzIFNwaW5lQm91bmRzUHJvdmlkZXIge1xuXHQvKipcblx0ICogQHBhcmFtIGNsaXBwaW5nIElmIHRydWUsIGNsaXBwaW5nIGF0dGFjaG1lbnRzIGFyZSB1c2VkIHRvIGNvbXB1dGUgdGhlIGJvdW5kcy4gRmFsc2UsIGJ5IGRlZmF1bHQuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciAoXG5cdFx0cHJpdmF0ZSBjbGlwcGluZyA9IGZhbHNlLFxuXHQpIHsgfVxuXG5cdGNhbGN1bGF0ZUJvdW5kcyAoZ2FtZU9iamVjdDogU3BpbmUpIHtcblx0XHRpZiAoIWdhbWVPYmplY3Quc2tlbGV0b24pIHJldHVybiB7IHg6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcblx0XHQvLyBNYWtlIGEgY29weSBvZiBhbmltYXRpb24gc3RhdGUgYW5kIHNrZWxldG9uIGFzIHRoaXMgbWlnaHQgYmUgY2FsbGVkIHdoaWxlXG5cdFx0Ly8gdGhlIHNrZWxldG9uIGluIHRoZSBHYW1lT2JqZWN0IGhhcyBhbHJlYWR5IGJlZW4gaGVhdmlseSBtb2RpZmllZC4gV2UgY2FuIG5vdFxuXHRcdC8vIHJlY29uc3RydWN0IHRoYXQgc3RhdGUuXG5cdFx0Y29uc3Qgc2tlbGV0b24gPSBuZXcgU2tlbGV0b24oZ2FtZU9iamVjdC5za2VsZXRvbi5kYXRhKTtcblx0XHRza2VsZXRvbi5zZXRUb1NldHVwUG9zZSgpO1xuXHRcdHNrZWxldG9uLnVwZGF0ZVdvcmxkVHJhbnNmb3JtKFBoeXNpY3MudXBkYXRlKTtcblx0XHRjb25zdCBib3VuZHMgPSBza2VsZXRvbi5nZXRCb3VuZHNSZWN0KHRoaXMuY2xpcHBpbmcgPyBuZXcgU2tlbGV0b25DbGlwcGluZygpIDogdW5kZWZpbmVkKTtcblx0XHRyZXR1cm4gYm91bmRzLndpZHRoID09IE51bWJlci5ORUdBVElWRV9JTkZJTklUWVxuXHRcdFx0PyB7IHg6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfVxuXHRcdFx0OiBib3VuZHM7XG5cdH1cbn1cblxuLyoqIEEgYm91bmRzIHByb3ZpZGVyIHRoYXQgY2FsY3VsYXRlcyB0aGUgYm91bmRpbmcgYm94IGJ5IHRha2luZyB0aGUgbWF4aW11bWcgYm91bmRpbmcgYm94IGZvciBhIGNvbWJpbmF0aW9uIG9mIHNraW5zIGFuZCBzcGVjaWZpYyBhbmltYXRpb24uICovXG5leHBvcnQgY2xhc3MgU2tpbnNBbmRBbmltYXRpb25Cb3VuZHNQcm92aWRlclxuXHRpbXBsZW1lbnRzIFNwaW5lQm91bmRzUHJvdmlkZXIge1xuXHQvKipcblx0ICogQHBhcmFtIGFuaW1hdGlvbiBUaGUgYW5pbWF0aW9uIHRvIHVzZSBmb3IgY2FsY3VsYXRpbmcgdGhlIGJvdW5kcy4gSWYgbnVsbCwgdGhlIHNldHVwIHBvc2UgaXMgdXNlZC5cblx0ICogQHBhcmFtIHNraW5zIFRoZSBza2lucyB0byB1c2UgZm9yIGNhbGN1bGF0aW5nIHRoZSBib3VuZHMuIElmIGVtcHR5LCB0aGUgZGVmYXVsdCBza2luIGlzIHVzZWQuXG5cdCAqIEBwYXJhbSB0aW1lU3RlcCBUaGUgdGltZSBzdGVwIHRvIHVzZSBmb3IgY2FsY3VsYXRpbmcgdGhlIGJvdW5kcy4gQSBzbWFsbGVyIHRpbWUgc3RlcCBtZWFucyBtb3JlIHByZWNpc2lvbiwgYnV0IHNsb3dlciBjYWxjdWxhdGlvbi5cblx0ICogQHBhcmFtIGNsaXBwaW5nIElmIHRydWUsIGNsaXBwaW5nIGF0dGFjaG1lbnRzIGFyZSB1c2VkIHRvIGNvbXB1dGUgdGhlIGJvdW5kcy4gRmFsc2UsIGJ5IGRlZmF1bHQuXG5cdCAqL1xuXHRjb25zdHJ1Y3RvciAoXG5cdFx0cHJpdmF0ZSBhbmltYXRpb246IHN0cmluZyB8IG51bGwsXG5cdFx0cHJpdmF0ZSBza2luczogc3RyaW5nW10gPSBbXSxcblx0XHRwcml2YXRlIHRpbWVTdGVwOiBudW1iZXIgPSAwLjA1LFxuXHRcdHByaXZhdGUgY2xpcHBpbmcgPSBmYWxzZSxcblx0KSB7IH1cblxuXHRjYWxjdWxhdGVCb3VuZHMgKGdhbWVPYmplY3Q6IFNwaW5lKToge1xuXHRcdHg6IG51bWJlcjtcblx0XHR5OiBudW1iZXI7XG5cdFx0d2lkdGg6IG51bWJlcjtcblx0XHRoZWlnaHQ6IG51bWJlcjtcblx0fSB7XG5cdFx0aWYgKCFnYW1lT2JqZWN0LnNrZWxldG9uIHx8ICFnYW1lT2JqZWN0LnN0YXRlKVxuXHRcdFx0cmV0dXJuIHsgeDogMCwgeTogMCwgd2lkdGg6IDAsIGhlaWdodDogMCB9O1xuXHRcdC8vIE1ha2UgYSBjb3B5IG9mIGFuaW1hdGlvbiBzdGF0ZSBhbmQgc2tlbGV0b24gYXMgdGhpcyBtaWdodCBiZSBjYWxsZWQgd2hpbGVcblx0XHQvLyB0aGUgc2tlbGV0b24gaW4gdGhlIEdhbWVPYmplY3QgaGFzIGFscmVhZHkgYmVlbiBoZWF2aWx5IG1vZGlmaWVkLiBXZSBjYW4gbm90XG5cdFx0Ly8gcmVjb25zdHJ1Y3QgdGhhdCBzdGF0ZS5cblx0XHRjb25zdCBhbmltYXRpb25TdGF0ZSA9IG5ldyBBbmltYXRpb25TdGF0ZShnYW1lT2JqZWN0LnN0YXRlLmRhdGEpO1xuXHRcdGNvbnN0IHNrZWxldG9uID0gbmV3IFNrZWxldG9uKGdhbWVPYmplY3Quc2tlbGV0b24uZGF0YSk7XG5cdFx0Y29uc3QgY2xpcHBlciA9IHRoaXMuY2xpcHBpbmcgPyBuZXcgU2tlbGV0b25DbGlwcGluZygpIDogdW5kZWZpbmVkO1xuXHRcdGNvbnN0IGRhdGEgPSBza2VsZXRvbi5kYXRhO1xuXHRcdGlmICh0aGlzLnNraW5zLmxlbmd0aCA+IDApIHtcblx0XHRcdGxldCBjdXN0b21Ta2luID0gbmV3IFNraW4oXCJjdXN0b20tc2tpblwiKTtcblx0XHRcdGZvciAoY29uc3Qgc2tpbk5hbWUgb2YgdGhpcy5za2lucykge1xuXHRcdFx0XHRjb25zdCBza2luID0gZGF0YS5maW5kU2tpbihza2luTmFtZSk7XG5cdFx0XHRcdGlmIChza2luID09IG51bGwpIGNvbnRpbnVlO1xuXHRcdFx0XHRjdXN0b21Ta2luLmFkZFNraW4oc2tpbik7XG5cdFx0XHR9XG5cdFx0XHRza2VsZXRvbi5zZXRTa2luKGN1c3RvbVNraW4pO1xuXHRcdH1cblx0XHRza2VsZXRvbi5zZXRUb1NldHVwUG9zZSgpO1xuXG5cdFx0Y29uc3QgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb24gIT0gbnVsbCA/IGRhdGEuZmluZEFuaW1hdGlvbih0aGlzLmFuaW1hdGlvbiEpIDogbnVsbDtcblxuXHRcdGlmIChhbmltYXRpb24gPT0gbnVsbCkge1xuXHRcdFx0c2tlbGV0b24udXBkYXRlV29ybGRUcmFuc2Zvcm0oUGh5c2ljcy51cGRhdGUpO1xuXHRcdFx0Y29uc3QgYm91bmRzID0gc2tlbGV0b24uZ2V0Qm91bmRzUmVjdChjbGlwcGVyKTtcblx0XHRcdHJldHVybiBib3VuZHMud2lkdGggPT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXG5cdFx0XHRcdD8geyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH1cblx0XHRcdFx0OiBib3VuZHM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxldCBtaW5YID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuXHRcdFx0XHRtaW5ZID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuXHRcdFx0XHRtYXhYID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLFxuXHRcdFx0XHRtYXhZID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuXHRcdFx0YW5pbWF0aW9uU3RhdGUuY2xlYXJUcmFja3MoKTtcblx0XHRcdGFuaW1hdGlvblN0YXRlLnNldEFuaW1hdGlvbldpdGgoMCwgYW5pbWF0aW9uLCBmYWxzZSk7XG5cdFx0XHRjb25zdCBzdGVwcyA9IE1hdGgubWF4KGFuaW1hdGlvbi5kdXJhdGlvbiAvIHRoaXMudGltZVN0ZXAsIDEuMCk7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHN0ZXBzOyBpKyspIHtcblx0XHRcdFx0Y29uc3QgZGVsdGEgPSBpID4gMCA/IHRoaXMudGltZVN0ZXAgOiAwO1xuXHRcdFx0XHRhbmltYXRpb25TdGF0ZS51cGRhdGUoZGVsdGEpO1xuXHRcdFx0XHRhbmltYXRpb25TdGF0ZS5hcHBseShza2VsZXRvbik7XG5cdFx0XHRcdHNrZWxldG9uLnVwZGF0ZShkZWx0YSk7XG5cdFx0XHRcdHNrZWxldG9uLnVwZGF0ZVdvcmxkVHJhbnNmb3JtKFBoeXNpY3MudXBkYXRlKTtcblxuXHRcdFx0XHRjb25zdCBib3VuZHMgPSBza2VsZXRvbi5nZXRCb3VuZHNSZWN0KGNsaXBwZXIpO1xuXHRcdFx0XHRtaW5YID0gTWF0aC5taW4obWluWCwgYm91bmRzLngpO1xuXHRcdFx0XHRtaW5ZID0gTWF0aC5taW4obWluWSwgYm91bmRzLnkpO1xuXHRcdFx0XHRtYXhYID0gTWF0aC5tYXgobWF4WCwgYm91bmRzLnggKyBib3VuZHMud2lkdGgpO1xuXHRcdFx0XHRtYXhZID0gTWF0aC5tYXgobWF4WSwgYm91bmRzLnkgKyBib3VuZHMuaGVpZ2h0KTtcblx0XHRcdH1cblx0XHRcdGNvbnN0IGJvdW5kcyA9IHtcblx0XHRcdFx0eDogbWluWCxcblx0XHRcdFx0eTogbWluWSxcblx0XHRcdFx0d2lkdGg6IG1heFggLSBtaW5YLFxuXHRcdFx0XHRoZWlnaHQ6IG1heFkgLSBtaW5ZLFxuXHRcdFx0fTtcblx0XHRcdHJldHVybiBib3VuZHMud2lkdGggPT0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZXG5cdFx0XHRcdD8geyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH1cblx0XHRcdFx0OiBib3VuZHM7XG5cdFx0fVxuXHR9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3BpbmVPcHRpb25zIGV4dGVuZHMgQ29udGFpbmVyT3B0aW9ucyB7XG5cdC8qKiB0aGUge0BsaW5rIFNrZWxldG9uRGF0YX0gdXNlZCB0byBpbnN0YW50aWF0ZSB0aGUgc2tlbGV0b24gKi9cblx0c2tlbGV0b25EYXRhOiBTa2VsZXRvbkRhdGE7XG5cblx0LyoqICBTZWUge0BsaW5rIFNwaW5lRnJvbU9wdGlvbnMuYXV0b1VwZGF0ZX0uICovXG5cdGF1dG9VcGRhdGU/OiBib29sZWFuO1xuXG5cdC8qKiAgU2VlIHtAbGluayBTcGluZUZyb21PcHRpb25zLmRhcmtUaW50fS4gKi9cblx0ZGFya1RpbnQ/OiBib29sZWFuO1xuXG5cdC8qKiAgU2VlIHtAbGluayBTcGluZUZyb21PcHRpb25zLmJvdW5kc1Byb3ZpZGVyfS4gKi9cblx0Ym91bmRzUHJvdmlkZXI/OiBTcGluZUJvdW5kc1Byb3ZpZGVyLFxufVxuXG4vKipcbiAqIEFuaW1hdGlvblN0YXRlTGlzdGVuZXIge0BsaW5rIGh0dHBzOi8vZW4uZXNvdGVyaWNzb2Z0d2FyZS5jb20vc3BpbmUtYXBpLXJlZmVyZW5jZSNBbmltYXRpb25TdGF0ZUxpc3RlbmVyIGV2ZW50c30gZXhwb3NlZCBmb3IgUGl4aS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTcGluZUV2ZW50cyB7XG5cdGNvbXBsZXRlOiBbdHJhY2tFbnRyeTogVHJhY2tFbnRyeV07XG5cdGRpc3Bvc2U6IFt0cmFja0VudHJ5OiBUcmFja0VudHJ5XTtcblx0ZW5kOiBbdHJhY2tFbnRyeTogVHJhY2tFbnRyeV07XG5cdGV2ZW50OiBbdHJhY2tFbnRyeTogVHJhY2tFbnRyeSwgZXZlbnQ6IEV2ZW50XTtcblx0aW50ZXJydXB0OiBbdHJhY2tFbnRyeTogVHJhY2tFbnRyeV07XG5cdHN0YXJ0OiBbdHJhY2tFbnRyeTogVHJhY2tFbnRyeV07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXR0YWNobWVudENhY2hlRGF0YSB7XG5cdGlkOiBzdHJpbmc7XG5cdGNsaXBwZWQ6IGJvb2xlYW47XG5cdHZlcnRpY2VzOiBGbG9hdDMyQXJyYXk7XG5cdHV2czogRmxvYXQzMkFycmF5O1xuXHRpbmRpY2VzOiBudW1iZXJbXTtcblx0Y29sb3I6IENvbG9yO1xuXHRkYXJrQ29sb3I6IENvbG9yO1xuXHRkYXJrVGludDogYm9vbGVhbjtcblx0c2tpcFJlbmRlcjogYm9vbGVhbjtcblx0dGV4dHVyZTogVGV4dHVyZTtcblx0Y2xpcHBlZERhdGE/OiB7XG5cdFx0dmVydGljZXM6IEZsb2F0MzJBcnJheTtcblx0XHR1dnM6IEZsb2F0MzJBcnJheTtcblx0XHRpbmRpY2VzOiBVaW50MTZBcnJheTtcblx0XHR2ZXJ0ZXhDb3VudDogbnVtYmVyO1xuXHRcdGluZGljZXNDb3VudDogbnVtYmVyO1xuXHR9O1xufVxuXG5pbnRlcmZhY2UgU2xvdHNUb0NsaXBwaW5nIHtcblx0c2xvdDogU2xvdCxcblx0bWFzaz86IEdyYXBoaWNzLFxuXHRtYXNrQ29tcHV0ZWQ/OiBib29sZWFuLFxuXHR2ZXJ0aWNlczogQXJyYXk8bnVtYmVyPixcbn07XG5cbmNvbnN0IG1hc2tQb29sID0gbmV3IFBvb2w8R3JhcGhpY3M+KCgpID0+IG5ldyBHcmFwaGljcyk7XG5cbi8qKlxuICogVGhlIGNsYXNzIHRvIGluc3RhbnRpYXRlIGEge0BsaW5rIFNwaW5lfSBnYW1lIG9iamVjdCBpbiBQaXhpLlxuICogVGhlIHN0YXRpYyBtZXRob2Qge0BsaW5rIFNwaW5lLmZyb219IHNob3VsZCBiZSB1c2VkIHRvIGluc3RhbnRpYXRlIGEgU3BpbmUgZ2FtZSBvYmplY3QuXG4gKi9cbmV4cG9ydCBjbGFzcyBTcGluZSBleHRlbmRzIFZpZXdDb250YWluZXIge1xuXHQvLyBQaXhpIHByb3BlcnRpZXNcblx0cHVibGljIGJhdGNoZWQgPSB0cnVlO1xuXHRwdWJsaWMgYnVpbGRJZCA9IDA7XG5cdHB1YmxpYyBvdmVycmlkZSByZWFkb25seSByZW5kZXJQaXBlSWQgPSAnc3BpbmUnO1xuXHRwdWJsaWMgX2RpZFNwaW5lVXBkYXRlID0gZmFsc2U7XG5cblx0cHVibGljIGJlZm9yZVVwZGF0ZVdvcmxkVHJhbnNmb3JtczogKG9iamVjdDogU3BpbmUpID0+IHZvaWQgPSAoKSA9PiB7IC8qKiAqLyB9O1xuXHRwdWJsaWMgYWZ0ZXJVcGRhdGVXb3JsZFRyYW5zZm9ybXM6IChvYmplY3Q6IFNwaW5lKSA9PiB2b2lkID0gKCkgPT4geyAvKiogKi8gfTtcblxuXHQvLyBTcGluZSBwcm9wZXJ0aWVzXG5cdC8qKiBUaGUgc2tlbGV0b24gZm9yIHRoaXMgU3BpbmUgZ2FtZSBvYmplY3QuICovXG5cdHB1YmxpYyBza2VsZXRvbjogU2tlbGV0b247XG5cdC8qKiBUaGUgYW5pbWF0aW9uIHN0YXRlIGZvciB0aGlzIFNwaW5lIGdhbWUgb2JqZWN0LiAqL1xuXHRwdWJsaWMgc3RhdGU6IEFuaW1hdGlvblN0YXRlO1xuXHRwdWJsaWMgc2tlbGV0b25Cb3VuZHM/OiBTa2VsZXRvbkJvdW5kcztcblxuXHRwcml2YXRlIGRhcmtUaW50ID0gZmFsc2U7XG5cdHByaXZhdGUgX2RlYnVnPzogSVNwaW5lRGVidWdSZW5kZXJlciB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcblxuXHRyZWFkb25seSBfc2xvdHNPYmplY3Q6IFJlY29yZDxzdHJpbmcsIHsgc2xvdDogU2xvdCwgY29udGFpbmVyOiBDb250YWluZXIsIGZvbGxvd0F0dGFjaG1lbnRUaW1lbGluZTogYm9vbGVhbiB9IHwgbnVsbD4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXHRwcml2YXRlIGNsaXBwaW5nU2xvdFRvUGl4aU1hc2tzOiBSZWNvcmQ8c3RyaW5nLCBTbG90c1RvQ2xpcHBpbmc+ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuXHRwcml2YXRlIGdldFNsb3RGcm9tUmVmIChzbG90UmVmOiBudW1iZXIgfCBzdHJpbmcgfCBTbG90KTogU2xvdCB7XG5cdFx0bGV0IHNsb3Q6IFNsb3QgfCBudWxsO1xuXG5cdFx0aWYgKHR5cGVvZiBzbG90UmVmID09PSAnbnVtYmVyJykgc2xvdCA9IHRoaXMuc2tlbGV0b24uc2xvdHNbc2xvdFJlZl07XG5cdFx0ZWxzZSBpZiAodHlwZW9mIHNsb3RSZWYgPT09ICdzdHJpbmcnKSBzbG90ID0gdGhpcy5za2VsZXRvbi5maW5kU2xvdChzbG90UmVmKTtcblx0XHRlbHNlIHNsb3QgPSBzbG90UmVmO1xuXG5cdFx0aWYgKCFzbG90KSB0aHJvdyBuZXcgRXJyb3IoYE5vIHNsb3QgZm91bmQgd2l0aCB0aGUgZ2l2ZW4gc2xvdCByZWZlcmVuY2U6ICR7c2xvdFJlZn1gKTtcblxuXHRcdHJldHVybiBzbG90O1xuXHR9XG5cblx0cHVibGljIHNwaW5lQXR0YWNobWVudHNEaXJ0eSA9IHRydWU7XG5cdHB1YmxpYyBzcGluZVRleHR1cmVzRGlydHkgPSB0cnVlO1xuXG5cdHByaXZhdGUgX2xhc3RBdHRhY2htZW50czogQXR0YWNobWVudFtdID0gW107XG5cblx0cHJpdmF0ZSBfc3RhdGVDaGFuZ2VkID0gdHJ1ZTtcblx0cHJpdmF0ZSBhdHRhY2htZW50Q2FjaGVEYXRhOiBSZWNvcmQ8c3RyaW5nLCBBdHRhY2htZW50Q2FjaGVEYXRhPltdID0gW107XG5cblx0cHVibGljIGdldCBkZWJ1ZyAoKTogSVNwaW5lRGVidWdSZW5kZXJlciB8IHVuZGVmaW5lZCB7XG5cdFx0cmV0dXJuIHRoaXMuX2RlYnVnO1xuXHR9XG5cblx0LyoqIFBhc3MgYSB7QGxpbmsgU3BpbmVEZWJ1Z1JlbmRlcmVyfSBvciBjcmVhdGUgeW91ciBvd24ge0BsaW5rIElTcGluZURlYnVnUmVuZGVyZXJ9IHRvIHJlbmRlciBib25lcywgbWVzaGVzLCAuLi5cblx0ICogQGV4YW1wbGUgc3BpbmVHTy5kZWJ1ZyA9IG5ldyBTcGluZURlYnVnUmVuZGVyZXIoKTtcblx0ICovXG5cdHB1YmxpYyBzZXQgZGVidWcgKHZhbHVlOiBJU3BpbmVEZWJ1Z1JlbmRlcmVyIHwgdW5kZWZpbmVkKSB7XG5cdFx0aWYgKHRoaXMuX2RlYnVnKSB7XG5cdFx0XHR0aGlzLl9kZWJ1Zy51bnJlZ2lzdGVyU3BpbmUodGhpcyk7XG5cdFx0fVxuXHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0dmFsdWUucmVnaXN0ZXJTcGluZSh0aGlzKTtcblx0XHR9XG5cdFx0dGhpcy5fZGVidWcgPSB2YWx1ZTtcblx0fVxuXG5cdHByaXZhdGUgX2F1dG9VcGRhdGUgPSB0cnVlO1xuXG5cdHB1YmxpYyBnZXQgYXV0b1VwZGF0ZSAoKTogYm9vbGVhbiB7XG5cdFx0cmV0dXJuIHRoaXMuX2F1dG9VcGRhdGU7XG5cdH1cblx0LyoqIFdoZW4gYHRydWVgLCB0aGUgU3BpbmUgQW5pbWF0aW9uU3RhdGUgYW5kIHRoZSBTa2VsZXRvbiB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgdXBkYXRlZCB1c2luZyB0aGUge0BsaW5rIFRpY2tlci5zaGFyZWR9IGluc3RhbmNlLiAqL1xuXHRwdWJsaWMgc2V0IGF1dG9VcGRhdGUgKHZhbHVlOiBib29sZWFuKSB7XG5cdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRUaWNrZXIuc2hhcmVkLmFkZCh0aGlzLmludGVybmFsVXBkYXRlLCB0aGlzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0VGlja2VyLnNoYXJlZC5yZW1vdmUodGhpcy5pbnRlcm5hbFVwZGF0ZSwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fYXV0b1VwZGF0ZSA9IHZhbHVlO1xuXHR9XG5cblx0cHJpdmF0ZSBfYm91bmRzUHJvdmlkZXI/OiBTcGluZUJvdW5kc1Byb3ZpZGVyO1xuXHQvKiogVGhlIGJvdW5kcyBwcm92aWRlciB0byB1c2UuIElmIHVuZGVmaW5lZCB0aGUgYm91bmRzIHdpbGwgYmUgZHluYW1pYywgY2FsY3VsYXRlZCB3aGVuIHJlcXVlc3RlZCBhbmQgYmFzZWQgb24gdGhlIGN1cnJlbnQgZnJhbWUuICovXG5cdHB1YmxpYyBnZXQgYm91bmRzUHJvdmlkZXIgKCk6IFNwaW5lQm91bmRzUHJvdmlkZXIgfCB1bmRlZmluZWQge1xuXHRcdHJldHVybiB0aGlzLl9ib3VuZHNQcm92aWRlcjtcblx0fVxuXHRwdWJsaWMgc2V0IGJvdW5kc1Byb3ZpZGVyICh2YWx1ZTogU3BpbmVCb3VuZHNQcm92aWRlciB8IHVuZGVmaW5lZCkge1xuXHRcdHRoaXMuX2JvdW5kc1Byb3ZpZGVyID0gdmFsdWU7XG5cdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHR0aGlzLl9ib3VuZHNEaXJ0eSA9IGZhbHNlO1xuXHRcdH1cblx0XHR0aGlzLnVwZGF0ZUJvdW5kcygpO1xuXHR9XG5cblx0cHJpdmF0ZSBoYXNOZXZlclVwZGF0ZWQgPSB0cnVlO1xuXHRjb25zdHJ1Y3RvciAob3B0aW9uczogU3BpbmVPcHRpb25zIHwgU2tlbGV0b25EYXRhKSB7XG5cdFx0aWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBTa2VsZXRvbkRhdGEpIHtcblx0XHRcdG9wdGlvbnMgPSB7XG5cdFx0XHRcdHNrZWxldG9uRGF0YTogb3B0aW9ucyxcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0c3VwZXIoe30pO1xuXG5cdFx0dGhpcy5hbGxvd0NoaWxkcmVuID0gdHJ1ZTtcblxuXHRcdGNvbnN0IHNrZWxldG9uRGF0YSA9IG9wdGlvbnMgaW5zdGFuY2VvZiBTa2VsZXRvbkRhdGEgPyBvcHRpb25zIDogb3B0aW9ucy5za2VsZXRvbkRhdGE7XG5cblx0XHR0aGlzLnNrZWxldG9uID0gbmV3IFNrZWxldG9uKHNrZWxldG9uRGF0YSk7XG5cdFx0dGhpcy5zdGF0ZSA9IG5ldyBBbmltYXRpb25TdGF0ZShuZXcgQW5pbWF0aW9uU3RhdGVEYXRhKHNrZWxldG9uRGF0YSkpO1xuXHRcdHRoaXMuYXV0b1VwZGF0ZSA9IG9wdGlvbnM/LmF1dG9VcGRhdGUgPz8gdHJ1ZTtcblxuXHRcdC8vIGRhcmsgdGludCBjYW4gYmUgZW5hYmxlZCBieSBvcHRpb25zLCBvdGhlcndpc2UgaXMgZW5hYmxlIGlmIGF0IGxlYXN0IG9uZSBzbG90IGhhcyB0aW50IGJsYWNrXG5cdFx0dGhpcy5kYXJrVGludCA9IG9wdGlvbnM/LmRhcmtUaW50ID09PSB1bmRlZmluZWRcblx0XHRcdD8gdGhpcy5za2VsZXRvbi5zbG90cy5zb21lKHNsb3QgPT4gISFzbG90LmRhdGEuZGFya0NvbG9yKVxuXHRcdFx0OiBvcHRpb25zPy5kYXJrVGludDtcblxuXHRcdGNvbnN0IHNsb3RzID0gdGhpcy5za2VsZXRvbi5zbG90cztcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgc2xvdHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHRoaXMuYXR0YWNobWVudENhY2hlRGF0YVtpXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fYm91bmRzUHJvdmlkZXIgPSBvcHRpb25zLmJvdW5kc1Byb3ZpZGVyO1xuXHR9XG5cblx0LyoqIElmIHtAbGluayBTcGluZS5hdXRvVXBkYXRlfSBpcyBgZmFsc2VgLCB0aGlzIG1ldGhvZCBhbGxvd3MgdG8gdXBkYXRlIHRoZSBBbmltYXRpb25TdGF0ZSBhbmQgdGhlIFNrZWxldG9uIHdpdGggdGhlIGdpdmVuIGRlbHRhLiAqL1xuXHRwdWJsaWMgdXBkYXRlIChkdDogbnVtYmVyKTogdm9pZCB7XG5cdFx0dGhpcy5pbnRlcm5hbFVwZGF0ZSgwLCBkdCk7XG5cdH1cblxuXHRwcm90ZWN0ZWQgaW50ZXJuYWxVcGRhdGUgKF9kZWx0YUZyYW1lOiBhbnksIGRlbHRhU2Vjb25kcz86IG51bWJlcik6IHZvaWQge1xuXHRcdC8vIEJlY2F1c2UgcmVhc29ucywgcGl4aSB1c2VzIGRlbHRhRnJhbWVzIGF0IDYwZnBzLlxuXHRcdC8vIFdlIGlnbm9yZSB0aGUgZGVmYXVsdCBkZWx0YUZyYW1lcyBhbmQgdXNlIHRoZSBkZWx0YVNlY29uZHMgZnJvbSBwaXhpIHRpY2tlci5cblx0XHR0aGlzLl91cGRhdGVBbmRBcHBseVN0YXRlKGRlbHRhU2Vjb25kcyA/PyBUaWNrZXIuc2hhcmVkLmRlbHRhTVMgLyAxMDAwKTtcblx0fVxuXG5cdG92ZXJyaWRlIGdldCBib3VuZHMgKCkge1xuXHRcdGlmICh0aGlzLl9ib3VuZHNEaXJ0eSkge1xuXHRcdFx0dGhpcy51cGRhdGVCb3VuZHMoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5fYm91bmRzO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNldCB0aGUgcG9zaXRpb24gb2YgdGhlIGJvbmUgZ2l2ZW4gaW4gaW5wdXQgdGhyb3VnaCBhIHtAbGluayBJUG9pbnREYXRhfS5cblx0ICogQHBhcmFtIGJvbmU6IHRoZSBib25lIG5hbWUgb3IgdGhlIGJvbmUgaW5zdGFuY2UgdG8gc2V0IHRoZSBwb3NpdGlvblxuXHQgKiBAcGFyYW0gb3V0UG9zOiB0aGUgbmV3IHBvc2l0aW9uIG9mIHRoZSBib25lLlxuXHQgKiBAdGhyb3dzIHtFcnJvcn06IGlmIHRoZSBnaXZlbiBib25lIGlzIG5vdCBmb3VuZCBpbiB0aGUgc2tlbGV0b24sIGFuIGVycm9yIGlzIHRocm93blxuXHQgKi9cblx0cHVibGljIHNldEJvbmVQb3NpdGlvbiAoYm9uZTogc3RyaW5nIHwgQm9uZSwgcG9zaXRpb246IFBvaW50RGF0YSk6IHZvaWQge1xuXHRcdGNvbnN0IGJvbmVBdXggPSBib25lO1xuXG5cdFx0aWYgKHR5cGVvZiBib25lID09PSAnc3RyaW5nJykge1xuXHRcdFx0Ym9uZSA9IHRoaXMuc2tlbGV0b24uZmluZEJvbmUoYm9uZSkgYXMgQm9uZTtcblx0XHR9XG5cblx0XHRpZiAoIWJvbmUpIHRocm93IEVycm9yKGBDYW50IHNldCBib25lIHBvc2l0aW9uLCBib25lICR7U3RyaW5nKGJvbmVBdXgpfSBub3QgZm91bmRgKTtcblx0XHR2ZWN0b3JBdXguc2V0KHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuXG5cdFx0aWYgKGJvbmUucGFyZW50KSB7XG5cdFx0XHRjb25zdCBhdXggPSBib25lLnBhcmVudC53b3JsZFRvTG9jYWwodmVjdG9yQXV4KTtcblxuXHRcdFx0Ym9uZS54ID0gYXV4Lng7XG5cdFx0XHRib25lLnkgPSAtYXV4Lnk7XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ym9uZS54ID0gdmVjdG9yQXV4Lng7XG5cdFx0XHRib25lLnkgPSB2ZWN0b3JBdXgueTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmV0dXJuIHRoZSBwb3NpdGlvbiBvZiB0aGUgYm9uZSBnaXZlbiBpbiBpbnB1dCBpbnRvIGFuIHtAbGluayBJUG9pbnREYXRhfS5cblx0ICogQHBhcmFtIGJvbmU6IHRoZSBib25lIG5hbWUgb3IgdGhlIGJvbmUgaW5zdGFuY2UgdG8gZ2V0IHRoZSBwb3NpdGlvbiBmcm9tXG5cdCAqIEBwYXJhbSBvdXRQb3M6IGFuIG9wdGlvbmFsIHtAbGluayBJUG9pbnREYXRhfSB0byB1c2UgdG8gcmV0dXJuIHRoZSBib25lIHBvc2l0aW9uLCByYXRoZXJuIHRoYW4gaW5zdGFudGlhdGluZyBhIG5ldyBvYmplY3QuXG5cdCAqIEByZXR1cm5zIHtJUG9pbnREYXRhIHwgdW5kZWZpbmVkfTogdGhlIHBvc2l0aW9uIG9mIHRoZSBib25lLCBvciB1bmRlZmluZWQgaWYgbm8gbWF0Y2hpbmcgYm9uZSBpcyBmb3VuZCBpbiB0aGUgc2tlbGV0b25cblx0ICovXG5cdHB1YmxpYyBnZXRCb25lUG9zaXRpb24gKGJvbmU6IHN0cmluZyB8IEJvbmUsIG91dFBvcz86IFBvaW50RGF0YSk6IFBvaW50RGF0YSB8IHVuZGVmaW5lZCB7XG5cdFx0Y29uc3QgYm9uZUF1eCA9IGJvbmU7XG5cblx0XHRpZiAodHlwZW9mIGJvbmUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRib25lID0gdGhpcy5za2VsZXRvbi5maW5kQm9uZShib25lKSBhcyBCb25lO1xuXHRcdH1cblxuXHRcdGlmICghYm9uZSkge1xuXHRcdFx0Y29uc29sZS5lcnJvcihgQ2FudCBzZXQgYm9uZSBwb3NpdGlvbiEgQm9uZSAke1N0cmluZyhib25lQXV4KX0gbm90IGZvdW5kYCk7XG5cblx0XHRcdHJldHVybiBvdXRQb3M7XG5cdFx0fVxuXG5cdFx0aWYgKCFvdXRQb3MpIHtcblx0XHRcdG91dFBvcyA9IHsgeDogMCwgeTogMCB9O1xuXHRcdH1cblxuXHRcdG91dFBvcy54ID0gYm9uZS53b3JsZFg7XG5cdFx0b3V0UG9zLnkgPSBib25lLndvcmxkWTtcblxuXHRcdHJldHVybiBvdXRQb3M7XG5cdH1cblxuXHQvKipcblx0ICogQWR2YW5jZSB0aGUgc3RhdGUgYW5kIHNrZWxldG9uIGJ5IHRoZSBnaXZlbiB0aW1lLCB0aGVuIHVwZGF0ZSBzbG90IG9iamVjdHMgdG9vLlxuXHQgKiBUaGUgY29udGFpbmVyIHRyYW5zZm9ybSBpcyBub3QgdXBkYXRlZC5cblx0ICpcblx0ICogQHBhcmFtIHRpbWUgdGhlIHRpbWUgYXQgd2hpY2ggdG8gc2V0IHRoZSBzdGF0ZVxuXHQgKi9cblx0cHJpdmF0ZSBfdXBkYXRlQW5kQXBwbHlTdGF0ZSAodGltZTogbnVtYmVyKSB7XG5cdFx0dGhpcy5oYXNOZXZlclVwZGF0ZWQgPSBmYWxzZTtcblxuXHRcdHRoaXMuc3RhdGUudXBkYXRlKHRpbWUpO1xuXHRcdHRoaXMuc2tlbGV0b24udXBkYXRlKHRpbWUpO1xuXG5cdFx0Y29uc3QgeyBza2VsZXRvbiB9ID0gdGhpcztcblxuXHRcdHRoaXMuc3RhdGUuYXBwbHkoc2tlbGV0b24pO1xuXG5cdFx0dGhpcy5iZWZvcmVVcGRhdGVXb3JsZFRyYW5zZm9ybXModGhpcyk7XG5cdFx0c2tlbGV0b24udXBkYXRlV29ybGRUcmFuc2Zvcm0oUGh5c2ljcy51cGRhdGUpO1xuXHRcdHRoaXMuYWZ0ZXJVcGRhdGVXb3JsZFRyYW5zZm9ybXModGhpcyk7XG5cblx0XHR0aGlzLnVwZGF0ZVNsb3RPYmplY3RzKCk7XG5cblx0XHR0aGlzLl9zdGF0ZUNoYW5nZWQgPSB0cnVlO1xuXG5cdFx0dGhpcy5vblZpZXdVcGRhdGUoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiAtIHZhbGlkYXRlcyB0aGUgYXR0YWNobWVudHMgLSB0byBmbGFnIGlmIHRoZSBhdHRhY2htZW50cyBoYXZlIGNoYW5nZWQgdGhpcyBzdGF0ZVxuXHQgKiAtIHRyYW5zZm9ybXMgdGhlIGF0dGFjaG1lbnRzIC0gdG8gdXBkYXRlIHRoZSB2ZXJ0aWNlcyBvZiB0aGUgYXR0YWNobWVudHMgYmFzZWQgb24gdGhlIG5ldyBwb3NpdGlvbnNcblx0ICogQGludGVybmFsXG5cdCAqL1xuXHRfdmFsaWRhdGVBbmRUcmFuc2Zvcm1BdHRhY2htZW50cyAoKSB7XG5cdFx0aWYgKCF0aGlzLl9zdGF0ZUNoYW5nZWQpIHJldHVybjtcblx0XHR0aGlzLl9zdGF0ZUNoYW5nZWQgPSBmYWxzZTtcblxuXHRcdHRoaXMudmFsaWRhdGVBdHRhY2htZW50cygpO1xuXG5cdFx0dGhpcy50cmFuc2Zvcm1BdHRhY2htZW50cygpO1xuXHR9XG5cblx0cHJpdmF0ZSB2YWxpZGF0ZUF0dGFjaG1lbnRzICgpIHtcblxuXHRcdGNvbnN0IGN1cnJlbnREcmF3T3JkZXIgPSB0aGlzLnNrZWxldG9uLmRyYXdPcmRlcjtcblxuXHRcdGNvbnN0IGxhc3RBdHRhY2htZW50cyA9IHRoaXMuX2xhc3RBdHRhY2htZW50cztcblxuXHRcdGxldCBpbmRleCA9IDA7XG5cblx0XHRsZXQgc3BpbmVBdHRhY2htZW50c0RpcnR5ID0gZmFsc2U7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJlbnREcmF3T3JkZXIubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IHNsb3QgPSBjdXJyZW50RHJhd09yZGVyW2ldO1xuXHRcdFx0Y29uc3QgYXR0YWNobWVudCA9IHNsb3QuZ2V0QXR0YWNobWVudCgpO1xuXG5cdFx0XHRpZiAoYXR0YWNobWVudCkge1xuXHRcdFx0XHRpZiAoYXR0YWNobWVudCAhPT0gbGFzdEF0dGFjaG1lbnRzW2luZGV4XSkge1xuXHRcdFx0XHRcdHNwaW5lQXR0YWNobWVudHNEaXJ0eSA9IHRydWU7XG5cdFx0XHRcdFx0bGFzdEF0dGFjaG1lbnRzW2luZGV4XSA9IGF0dGFjaG1lbnQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChpbmRleCAhPT0gbGFzdEF0dGFjaG1lbnRzLmxlbmd0aCkge1xuXHRcdFx0c3BpbmVBdHRhY2htZW50c0RpcnR5ID0gdHJ1ZTtcblx0XHRcdGxhc3RBdHRhY2htZW50cy5sZW5ndGggPSBpbmRleDtcblx0XHR9XG5cblx0XHR0aGlzLnNwaW5lQXR0YWNobWVudHNEaXJ0eSB8fD0gc3BpbmVBdHRhY2htZW50c0RpcnR5O1xuXHR9XG5cblx0cHJpdmF0ZSBjdXJyZW50Q2xpcHBpbmdTbG90OiBTbG90c1RvQ2xpcHBpbmcgfCB1bmRlZmluZWQ7XG5cdHByaXZhdGUgdXBkYXRlQW5kU2V0UGl4aU1hc2sgKHNsb3Q6IFNsb3QsIGxhc3Q6IGJvb2xlYW4pIHtcblx0XHQvLyBhc3NpZ24vY3JlYXRlIHRoZSBjdXJyZW50Q2xpcHBpbmdTbG90XG5cdFx0Y29uc3QgYXR0YWNobWVudCA9IHNsb3QuYXR0YWNobWVudDtcblx0XHRpZiAoYXR0YWNobWVudCAmJiBhdHRhY2htZW50IGluc3RhbmNlb2YgQ2xpcHBpbmdBdHRhY2htZW50KSB7XG5cdFx0XHRjb25zdCBjbGlwID0gKHRoaXMuY2xpcHBpbmdTbG90VG9QaXhpTWFza3Nbc2xvdC5kYXRhLm5hbWVdIHx8PSB7IHNsb3QsIHZlcnRpY2VzOiBuZXcgQXJyYXk8bnVtYmVyPigpIH0pO1xuXHRcdFx0Y2xpcC5tYXNrQ29tcHV0ZWQgPSBmYWxzZTtcblx0XHRcdHRoaXMuY3VycmVudENsaXBwaW5nU2xvdCA9IHRoaXMuY2xpcHBpbmdTbG90VG9QaXhpTWFza3Nbc2xvdC5kYXRhLm5hbWVdO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGFzc2lnbiB0aGUgY3VycmVudENsaXBwaW5nU2xvdCBtYXNrIHRvIHRoZSBzbG90IG9iamVjdFxuXHRcdGxldCBjdXJyZW50Q2xpcHBpbmdTbG90ID0gdGhpcy5jdXJyZW50Q2xpcHBpbmdTbG90O1xuXHRcdGxldCBzbG90T2JqZWN0ID0gdGhpcy5fc2xvdHNPYmplY3Rbc2xvdC5kYXRhLm5hbWVdO1xuXHRcdGlmIChjdXJyZW50Q2xpcHBpbmdTbG90ICYmIHNsb3RPYmplY3QpIHtcblx0XHRcdGxldCBzbG90Q2xpcHBpbmcgPSBjdXJyZW50Q2xpcHBpbmdTbG90LnNsb3Q7XG5cdFx0XHRsZXQgY2xpcHBpbmdBdHRhY2htZW50ID0gc2xvdENsaXBwaW5nLmF0dGFjaG1lbnQgYXMgQ2xpcHBpbmdBdHRhY2htZW50O1xuXG5cdFx0XHQvLyBjcmVhdGUgdGhlIHBpeGkgbWFzaywgb25seSB0aGUgZmlyc3QgdGltZSBhbmQgaWYgdGhlIGNsaXBwZWQgc2xvdCBpcyB0aGUgZmlyc3Qgb25lIGNsaXBwZWQgYnkgdGhpcyBjdXJyZW50Q2xpcHBpbmdTbG90XG5cdFx0XHRsZXQgbWFzayA9IGN1cnJlbnRDbGlwcGluZ1Nsb3QubWFzayBhcyBHcmFwaGljcztcblx0XHRcdGlmICghbWFzaykge1xuXHRcdFx0XHRtYXNrID0gbWFza1Bvb2wub2J0YWluKCk7XG5cdFx0XHRcdGN1cnJlbnRDbGlwcGluZ1Nsb3QubWFzayA9IG1hc2s7XG5cdFx0XHRcdHRoaXMuYWRkQ2hpbGQobWFzayk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNvbXB1dGUgdGhlIHBpeGkgbWFzayBwb2x5Z29uLCBpZiB0aGUgY2xpcHBlZCBzbG90IGlzIHRoZSBmaXJzdCBvbmUgY2xpcHBlZCBieSB0aGlzIGN1cnJlbnRDbGlwcGluZ1Nsb3Rcblx0XHRcdGlmICghY3VycmVudENsaXBwaW5nU2xvdC5tYXNrQ29tcHV0ZWQpIHtcblx0XHRcdFx0Y3VycmVudENsaXBwaW5nU2xvdC5tYXNrQ29tcHV0ZWQgPSB0cnVlO1xuXHRcdFx0XHRjb25zdCB3b3JsZFZlcnRpY2VzTGVuZ3RoID0gY2xpcHBpbmdBdHRhY2htZW50LndvcmxkVmVydGljZXNMZW5ndGg7XG5cdFx0XHRcdGNvbnN0IHZlcnRpY2VzID0gY3VycmVudENsaXBwaW5nU2xvdC52ZXJ0aWNlcztcblx0XHRcdFx0Y2xpcHBpbmdBdHRhY2htZW50LmNvbXB1dGVXb3JsZFZlcnRpY2VzKHNsb3RDbGlwcGluZywgMCwgd29ybGRWZXJ0aWNlc0xlbmd0aCwgdmVydGljZXMsIDAsIDIpO1xuXHRcdFx0XHRtYXNrLmNsZWFyKCkucG9seSh2ZXJ0aWNlcykuc3Ryb2tlKHsgd2lkdGg6IDAgfSkuZmlsbCh7IGFscGhhOiAuMjUgfSk7XG5cdFx0XHR9XG5cdFx0XHRzbG90T2JqZWN0LmNvbnRhaW5lci5tYXNrID0gbWFzaztcblx0XHR9IGVsc2UgaWYgKHNsb3RPYmplY3Q/LmNvbnRhaW5lci5tYXNrKSB7XG5cdFx0XHQvLyByZW1vdmUgdGhlIG1hc2ssIGlmIHNsb3Qgb2JqZWN0IGhhcyBhIG1hc2ssIGJ1dCBjdXJyZW50Q2xpcHBpbmdTbG90IGlzIHVuZGVmaW5lZFxuXHRcdFx0c2xvdE9iamVjdC5jb250YWluZXIubWFzayA9IG51bGw7XG5cdFx0fVxuXG5cdFx0Ly8gaWYgY3VycmVudCBzbG90IGlzIHRoZSBlbmRpbmcgb25lIG9mIHRoZSBjdXJyZW50Q2xpcHBpbmdTbG90IG1hc2ssIHNldCBjdXJyZW50Q2xpcHBpbmdTbG90IHRvIHVuZGVmaW5lZFxuXHRcdGlmIChjdXJyZW50Q2xpcHBpbmdTbG90ICYmIChjdXJyZW50Q2xpcHBpbmdTbG90LnNsb3QuYXR0YWNobWVudCBhcyBDbGlwcGluZ0F0dGFjaG1lbnQpLmVuZFNsb3QgPT0gc2xvdC5kYXRhKSB7XG5cdFx0XHR0aGlzLmN1cnJlbnRDbGlwcGluZ1Nsb3QgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gY2xlYW4gdXAgdW51c2VkIG1hc2tzXG5cdFx0aWYgKGxhc3QpIHtcblx0XHRcdGZvciAoY29uc3Qga2V5IGluIHRoaXMuY2xpcHBpbmdTbG90VG9QaXhpTWFza3MpIHtcblx0XHRcdFx0Y29uc3QgY2xpcHBpbmdTbG90VG9QaXhpTWFzayA9IHRoaXMuY2xpcHBpbmdTbG90VG9QaXhpTWFza3Nba2V5XTtcblx0XHRcdFx0aWYgKCghKGNsaXBwaW5nU2xvdFRvUGl4aU1hc2suc2xvdC5hdHRhY2htZW50IGluc3RhbmNlb2YgQ2xpcHBpbmdBdHRhY2htZW50KSB8fCAhY2xpcHBpbmdTbG90VG9QaXhpTWFzay5tYXNrQ29tcHV0ZWQpICYmIGNsaXBwaW5nU2xvdFRvUGl4aU1hc2subWFzaykge1xuXHRcdFx0XHRcdHRoaXMucmVtb3ZlQ2hpbGQoY2xpcHBpbmdTbG90VG9QaXhpTWFzay5tYXNrKTtcblx0XHRcdFx0XHRtYXNrUG9vbC5mcmVlKGNsaXBwaW5nU2xvdFRvUGl4aU1hc2subWFzayk7XG5cdFx0XHRcdFx0Y2xpcHBpbmdTbG90VG9QaXhpTWFzay5tYXNrID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmN1cnJlbnRDbGlwcGluZ1Nsb3QgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cblx0cHJpdmF0ZSB0cmFuc2Zvcm1BdHRhY2htZW50cyAoKSB7XG5cdFx0Y29uc3QgY3VycmVudERyYXdPcmRlciA9IHRoaXMuc2tlbGV0b24uZHJhd09yZGVyO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyZW50RHJhd09yZGVyLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBzbG90ID0gY3VycmVudERyYXdPcmRlcltpXTtcblxuXHRcdFx0dGhpcy51cGRhdGVBbmRTZXRQaXhpTWFzayhzbG90LCBpID09PSBjdXJyZW50RHJhd09yZGVyLmxlbmd0aCAtIDEpO1xuXG5cdFx0XHRjb25zdCBhdHRhY2htZW50ID0gc2xvdC5nZXRBdHRhY2htZW50KCk7XG5cblx0XHRcdGlmIChhdHRhY2htZW50KSB7XG5cdFx0XHRcdGlmIChhdHRhY2htZW50IGluc3RhbmNlb2YgTWVzaEF0dGFjaG1lbnQgfHwgYXR0YWNobWVudCBpbnN0YW5jZW9mIFJlZ2lvbkF0dGFjaG1lbnQpIHtcblx0XHRcdFx0XHRjb25zdCBjYWNoZURhdGEgPSB0aGlzLl9nZXRDYWNoZWREYXRhKHNsb3QsIGF0dGFjaG1lbnQpO1xuXG5cdFx0XHRcdFx0aWYgKGF0dGFjaG1lbnQgaW5zdGFuY2VvZiBSZWdpb25BdHRhY2htZW50KSB7XG5cdFx0XHRcdFx0XHRhdHRhY2htZW50LmNvbXB1dGVXb3JsZFZlcnRpY2VzKHNsb3QsIGNhY2hlRGF0YS52ZXJ0aWNlcywgMCwgMik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0YXR0YWNobWVudC5jb21wdXRlV29ybGRWZXJ0aWNlcyhcblx0XHRcdFx0XHRcdFx0c2xvdCxcblx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0YXR0YWNobWVudC53b3JsZFZlcnRpY2VzTGVuZ3RoLFxuXHRcdFx0XHRcdFx0XHRjYWNoZURhdGEudmVydGljZXMsXG5cdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdDIsXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIHNlcXVlbmNlcyB1dnMgYXJlIGtub3duIG9ubHkgYWZ0ZXIgY29tcHV0ZVdvcmxkVmVydGljZXMgaXMgaW52b2tlZFxuXHRcdFx0XHRcdGlmIChjYWNoZURhdGEudXZzLmxlbmd0aCA8IGF0dGFjaG1lbnQudXZzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0Y2FjaGVEYXRhLnV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoYXR0YWNobWVudC51dnMubGVuZ3RoKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBuZWVkIHRvIGNvcHkgYmVjYXVzZSBhdHRhY2htZW50cyB1dnMgYXJlIHNoYXJlZCBhbW9uZyBza2VsZXRvbnMgdXNpbmcgdGhlIHNhbWUgYXRsYXNcblx0XHRcdFx0XHRmYXN0Q29weSgoYXR0YWNobWVudC51dnMgYXMgRmxvYXQzMkFycmF5KS5idWZmZXIsIGNhY2hlRGF0YS51dnMuYnVmZmVyKTtcblxuXHRcdFx0XHRcdGNvbnN0IHNrZWxldG9uID0gc2xvdC5ib25lLnNrZWxldG9uO1xuXHRcdFx0XHRcdGNvbnN0IHNrZWxldG9uQ29sb3IgPSBza2VsZXRvbi5jb2xvcjtcblx0XHRcdFx0XHRjb25zdCBzbG90Q29sb3IgPSBzbG90LmNvbG9yO1xuXG5cdFx0XHRcdFx0Y29uc3QgYXR0YWNobWVudENvbG9yID0gYXR0YWNobWVudC5jb2xvcjtcblxuXHRcdFx0XHRcdGNhY2hlRGF0YS5jb2xvci5zZXQoXG5cdFx0XHRcdFx0XHRza2VsZXRvbkNvbG9yLnIgKiBzbG90Q29sb3IuciAqIGF0dGFjaG1lbnRDb2xvci5yLFxuXHRcdFx0XHRcdFx0c2tlbGV0b25Db2xvci5nICogc2xvdENvbG9yLmcgKiBhdHRhY2htZW50Q29sb3IuZyxcblx0XHRcdFx0XHRcdHNrZWxldG9uQ29sb3IuYiAqIHNsb3RDb2xvci5iICogYXR0YWNobWVudENvbG9yLmIsXG5cdFx0XHRcdFx0XHRza2VsZXRvbkNvbG9yLmEgKiBzbG90Q29sb3IuYSAqIGF0dGFjaG1lbnRDb2xvci5hLFxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRpZiAoc2xvdC5kYXJrQ29sb3IpIHtcblx0XHRcdFx0XHRcdGNhY2hlRGF0YS5kYXJrQ29sb3Iuc2V0RnJvbUNvbG9yKHNsb3QuZGFya0NvbG9yKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjYWNoZURhdGEuc2tpcFJlbmRlciA9IGNhY2hlRGF0YS5jbGlwcGVkID0gZmFsc2U7XG5cblx0XHRcdFx0XHRjb25zdCB0ZXh0dXJlID0gYXR0YWNobWVudC5yZWdpb24/LnRleHR1cmUudGV4dHVyZSB8fCBUZXh0dXJlLkVNUFRZO1xuXG5cdFx0XHRcdFx0aWYgKGNhY2hlRGF0YS50ZXh0dXJlICE9PSB0ZXh0dXJlKSB7XG5cdFx0XHRcdFx0XHRjYWNoZURhdGEudGV4dHVyZSA9IHRleHR1cmU7XG5cdFx0XHRcdFx0XHR0aGlzLnNwaW5lVGV4dHVyZXNEaXJ0eSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGNsaXBwZXIuaXNDbGlwcGluZygpKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnVwZGF0ZUNsaXBwaW5nRGF0YShjYWNoZURhdGEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmIChhdHRhY2htZW50IGluc3RhbmNlb2YgQ2xpcHBpbmdBdHRhY2htZW50KSB7XG5cdFx0XHRcdFx0Y2xpcHBlci5jbGlwU3RhcnQoc2xvdCwgYXR0YWNobWVudCk7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGNsaXBwZXIuY2xpcEVuZFdpdGhTbG90KHNsb3QpO1xuXHRcdH1cblx0XHRjbGlwcGVyLmNsaXBFbmQoKTtcblx0fVxuXG5cdHByaXZhdGUgdXBkYXRlQ2xpcHBpbmdEYXRhIChjYWNoZURhdGE6IEF0dGFjaG1lbnRDYWNoZURhdGEpIHtcblx0XHRjYWNoZURhdGEuY2xpcHBlZCA9IHRydWU7XG5cblx0XHRjbGlwcGVyLmNsaXBUcmlhbmdsZXNVbnBhY2tlZChcblx0XHRcdGNhY2hlRGF0YS52ZXJ0aWNlcyxcblx0XHRcdGNhY2hlRGF0YS5pbmRpY2VzLFxuXHRcdFx0Y2FjaGVEYXRhLmluZGljZXMubGVuZ3RoLFxuXHRcdFx0Y2FjaGVEYXRhLnV2cyxcblx0XHQpO1xuXG5cdFx0Y29uc3QgeyBjbGlwcGVkVmVydGljZXMsIGNsaXBwZWRVVnMsIGNsaXBwZWRUcmlhbmdsZXMgfSA9IGNsaXBwZXI7XG5cblx0XHRjb25zdCB2ZXJ0aWNlc0NvdW50ID0gY2xpcHBlZFZlcnRpY2VzLmxlbmd0aCAvIDI7XG5cdFx0Y29uc3QgaW5kaWNlc0NvdW50ID0gY2xpcHBlZFRyaWFuZ2xlcy5sZW5ndGg7XG5cblx0XHRpZiAoIWNhY2hlRGF0YS5jbGlwcGVkRGF0YSkge1xuXHRcdFx0Y2FjaGVEYXRhLmNsaXBwZWREYXRhID0ge1xuXHRcdFx0XHR2ZXJ0aWNlczogbmV3IEZsb2F0MzJBcnJheSh2ZXJ0aWNlc0NvdW50ICogMiksXG5cdFx0XHRcdHV2czogbmV3IEZsb2F0MzJBcnJheSh2ZXJ0aWNlc0NvdW50ICogMiksXG5cdFx0XHRcdHZlcnRleENvdW50OiB2ZXJ0aWNlc0NvdW50LFxuXHRcdFx0XHRpbmRpY2VzOiBuZXcgVWludDE2QXJyYXkoaW5kaWNlc0NvdW50KSxcblx0XHRcdFx0aW5kaWNlc0NvdW50LFxuXHRcdFx0fTtcblxuXHRcdFx0dGhpcy5zcGluZUF0dGFjaG1lbnRzRGlydHkgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGNvbnN0IGNsaXBwZWREYXRhID0gY2FjaGVEYXRhLmNsaXBwZWREYXRhO1xuXG5cdFx0Y29uc3Qgc2l6ZUNoYW5nZSA9IGNsaXBwZWREYXRhLnZlcnRleENvdW50ICE9PSB2ZXJ0aWNlc0NvdW50IHx8IGluZGljZXNDb3VudCAhPT0gY2xpcHBlZERhdGEuaW5kaWNlc0NvdW50O1xuXG5cdFx0Y2FjaGVEYXRhLnNraXBSZW5kZXIgPSB2ZXJ0aWNlc0NvdW50ID09PSAwO1xuXG5cdFx0aWYgKHNpemVDaGFuZ2UpIHtcblx0XHRcdHRoaXMuc3BpbmVBdHRhY2htZW50c0RpcnR5ID0gdHJ1ZTtcblxuXHRcdFx0aWYgKGNsaXBwZWREYXRhLnZlcnRleENvdW50IDwgdmVydGljZXNDb3VudCkge1xuXHRcdFx0XHQvLyBidWZmZXIgcmV1c2UhXG5cdFx0XHRcdGNsaXBwZWREYXRhLnZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSh2ZXJ0aWNlc0NvdW50ICogMik7XG5cdFx0XHRcdGNsaXBwZWREYXRhLnV2cyA9IG5ldyBGbG9hdDMyQXJyYXkodmVydGljZXNDb3VudCAqIDIpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoY2xpcHBlZERhdGEuaW5kaWNlcy5sZW5ndGggPCBpbmRpY2VzQ291bnQpIHtcblx0XHRcdFx0Y2xpcHBlZERhdGEuaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheShpbmRpY2VzQ291bnQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGNvbnN0IHsgdmVydGljZXMsIHV2cywgaW5kaWNlcyB9ID0gY2xpcHBlZERhdGE7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHZlcnRpY2VzQ291bnQ7IGkrKykge1xuXHRcdFx0dmVydGljZXNbaSAqIDJdID0gY2xpcHBlZFZlcnRpY2VzW2kgKiAyXTtcblx0XHRcdHZlcnRpY2VzWyhpICogMikgKyAxXSA9IGNsaXBwZWRWZXJ0aWNlc1soaSAqIDIpICsgMV07XG5cblx0XHRcdHV2c1tpICogMl0gPSBjbGlwcGVkVVZzWyhpICogMildO1xuXHRcdFx0dXZzWyhpICogMikgKyAxXSA9IGNsaXBwZWRVVnNbKGkgKiAyKSArIDFdO1xuXHRcdH1cblxuXHRcdGNsaXBwZWREYXRhLnZlcnRleENvdW50ID0gdmVydGljZXNDb3VudDtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgaW5kaWNlc0NvdW50OyBpKyspIHtcblx0XHRcdGlmIChpbmRpY2VzW2ldICE9PSBjbGlwcGVkVHJpYW5nbGVzW2ldKSB7XG5cdFx0XHRcdHRoaXMuc3BpbmVBdHRhY2htZW50c0RpcnR5ID0gdHJ1ZTtcblx0XHRcdFx0aW5kaWNlc1tpXSA9IGNsaXBwZWRUcmlhbmdsZXNbaV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y2xpcHBlZERhdGEuaW5kaWNlc0NvdW50ID0gaW5kaWNlc0NvdW50O1xuXHR9XG5cblx0LyoqXG5cdCAqIGVuc3VyZSB0aGF0IGF0dGFjaGVkIGNvbnRhaW5lcnMgbWFwIGNvcnJlY3RseSB0byB0aGVpciBzbG90c1xuXHQgKiBhbG9uZyB3aXRoIHRoZWlyIHBvc2l0aW9uLCByb3RhdGlvbiwgc2NhbGUsIGFuZCB2aXNpYmlsaXR5LlxuXHQgKi9cblx0cHJpdmF0ZSB1cGRhdGVTbG90T2JqZWN0cyAoKSB7XG5cdFx0Zm9yIChjb25zdCBpIGluIHRoaXMuX3Nsb3RzT2JqZWN0KSB7XG5cdFx0XHRjb25zdCBzbG90QXR0YWNobWVudCA9IHRoaXMuX3Nsb3RzT2JqZWN0W2ldO1xuXG5cdFx0XHRpZiAoIXNsb3RBdHRhY2htZW50KSBjb250aW51ZTtcblxuXHRcdFx0dGhpcy51cGRhdGVTbG90T2JqZWN0KHNsb3RBdHRhY2htZW50KTtcblx0XHR9XG5cdH1cblxuXHRwcml2YXRlIHVwZGF0ZVNsb3RPYmplY3QgKHNsb3RBdHRhY2htZW50OiB7IHNsb3Q6IFNsb3QsIGNvbnRhaW5lcjogQ29udGFpbmVyLCBmb2xsb3dBdHRhY2htZW50VGltZWxpbmU6IGJvb2xlYW4gfSkge1xuXHRcdGNvbnN0IHsgc2xvdCwgY29udGFpbmVyIH0gPSBzbG90QXR0YWNobWVudDtcblxuXHRcdGNvbnN0IGZvbGxvd0F0dGFjaG1lbnRWYWx1ZSA9IHNsb3RBdHRhY2htZW50LmZvbGxvd0F0dGFjaG1lbnRUaW1lbGluZSA/IEJvb2xlYW4oc2xvdC5hdHRhY2htZW50KSA6IHRydWU7XG5cdFx0Y29udGFpbmVyLnZpc2libGUgPSB0aGlzLnNrZWxldG9uLmRyYXdPcmRlci5pbmNsdWRlcyhzbG90KSAmJiBmb2xsb3dBdHRhY2htZW50VmFsdWU7XG5cblx0XHRpZiAoY29udGFpbmVyLnZpc2libGUpIHtcblx0XHRcdGxldCBib25lOiBCb25lIHwgbnVsbCA9IHNsb3QuYm9uZTtcblxuXHRcdFx0Y29udGFpbmVyLnBvc2l0aW9uLnNldChib25lLndvcmxkWCwgYm9uZS53b3JsZFkpO1xuXHRcdFx0Y29udGFpbmVyLmFuZ2xlID0gYm9uZS5nZXRXb3JsZFJvdGF0aW9uWCgpO1xuXG5cdFx0XHRsZXQgY3VtdWxhdGl2ZVNjYWxlWCA9IDE7XG5cdFx0XHRsZXQgY3VtdWxhdGl2ZVNjYWxlWSA9IDE7XG5cdFx0XHR3aGlsZSAoYm9uZSkge1xuXHRcdFx0XHRjdW11bGF0aXZlU2NhbGVYICo9IGJvbmUuc2NhbGVYO1xuXHRcdFx0XHRjdW11bGF0aXZlU2NhbGVZICo9IGJvbmUuc2NhbGVZO1xuXHRcdFx0XHRib25lID0gYm9uZS5wYXJlbnQ7XG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAoY3VtdWxhdGl2ZVNjYWxlWCA8IDApIGNvbnRhaW5lci5hbmdsZSAtPSAxODA7XG5cblx0XHRcdGNvbnRhaW5lci5zY2FsZS5zZXQoXG5cdFx0XHRcdHNsb3QuYm9uZS5nZXRXb3JsZFNjYWxlWCgpICogTWF0aC5zaWduKGN1bXVsYXRpdmVTY2FsZVgpLFxuXHRcdFx0XHRzbG90LmJvbmUuZ2V0V29ybGRTY2FsZVkoKSAqIE1hdGguc2lnbihjdW11bGF0aXZlU2NhbGVZKSxcblx0XHRcdCk7XG5cblx0XHRcdGNvbnRhaW5lci5hbHBoYSA9IHRoaXMuc2tlbGV0b24uY29sb3IuYSAqIHNsb3QuY29sb3IuYTtcblx0XHR9XG5cdH1cblxuXHQvKiogQGludGVybmFsICovXG5cdF9nZXRDYWNoZWREYXRhIChzbG90OiBTbG90LCBhdHRhY2htZW50OiBSZWdpb25BdHRhY2htZW50IHwgTWVzaEF0dGFjaG1lbnQpOiBBdHRhY2htZW50Q2FjaGVEYXRhIHtcblx0XHRyZXR1cm4gdGhpcy5hdHRhY2htZW50Q2FjaGVEYXRhW3Nsb3QuZGF0YS5pbmRleF1bYXR0YWNobWVudC5uYW1lXSB8fCB0aGlzLmluaXRDYWNoZWREYXRhKHNsb3QsIGF0dGFjaG1lbnQpO1xuXHR9XG5cblx0cHJpdmF0ZSBpbml0Q2FjaGVkRGF0YSAoc2xvdDogU2xvdCwgYXR0YWNobWVudDogUmVnaW9uQXR0YWNobWVudCB8IE1lc2hBdHRhY2htZW50KTogQXR0YWNobWVudENhY2hlRGF0YSB7XG5cdFx0bGV0IHZlcnRpY2VzOiBGbG9hdDMyQXJyYXk7XG5cblx0XHRpZiAoYXR0YWNobWVudCBpbnN0YW5jZW9mIFJlZ2lvbkF0dGFjaG1lbnQpIHtcblx0XHRcdHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSg4KTtcblxuXHRcdFx0dGhpcy5hdHRhY2htZW50Q2FjaGVEYXRhW3Nsb3QuZGF0YS5pbmRleF1bYXR0YWNobWVudC5uYW1lXSA9IHtcblx0XHRcdFx0aWQ6IGAke3Nsb3QuZGF0YS5pbmRleH0tJHthdHRhY2htZW50Lm5hbWV9YCxcblx0XHRcdFx0dmVydGljZXMsXG5cdFx0XHRcdGNsaXBwZWQ6IGZhbHNlLFxuXHRcdFx0XHRpbmRpY2VzOiBbMCwgMSwgMiwgMCwgMiwgM10sXG5cdFx0XHRcdHV2czogbmV3IEZsb2F0MzJBcnJheShhdHRhY2htZW50LnV2cy5sZW5ndGgpLFxuXHRcdFx0XHRjb2xvcjogbmV3IENvbG9yKDEsIDEsIDEsIDEpLFxuXHRcdFx0XHRkYXJrQ29sb3I6IG5ldyBDb2xvcigwLCAwLCAwLCAwKSxcblx0XHRcdFx0ZGFya1RpbnQ6IHRoaXMuZGFya1RpbnQsXG5cdFx0XHRcdHNraXBSZW5kZXI6IGZhbHNlLFxuXHRcdFx0XHR0ZXh0dXJlOiBhdHRhY2htZW50LnJlZ2lvbj8udGV4dHVyZS50ZXh0dXJlLFxuXHRcdFx0fTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHR2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoYXR0YWNobWVudC53b3JsZFZlcnRpY2VzTGVuZ3RoKTtcblxuXHRcdFx0dGhpcy5hdHRhY2htZW50Q2FjaGVEYXRhW3Nsb3QuZGF0YS5pbmRleF1bYXR0YWNobWVudC5uYW1lXSA9IHtcblx0XHRcdFx0aWQ6IGAke3Nsb3QuZGF0YS5pbmRleH0tJHthdHRhY2htZW50Lm5hbWV9YCxcblx0XHRcdFx0dmVydGljZXMsXG5cdFx0XHRcdGNsaXBwZWQ6IGZhbHNlLFxuXHRcdFx0XHRpbmRpY2VzOiBhdHRhY2htZW50LnRyaWFuZ2xlcyxcblx0XHRcdFx0dXZzOiBuZXcgRmxvYXQzMkFycmF5KGF0dGFjaG1lbnQudXZzLmxlbmd0aCksXG5cdFx0XHRcdGNvbG9yOiBuZXcgQ29sb3IoMSwgMSwgMSwgMSksXG5cdFx0XHRcdGRhcmtDb2xvcjogbmV3IENvbG9yKDAsIDAsIDAsIDApLFxuXHRcdFx0XHRkYXJrVGludDogdGhpcy5kYXJrVGludCxcblx0XHRcdFx0c2tpcFJlbmRlcjogZmFsc2UsXG5cdFx0XHRcdHRleHR1cmU6IGF0dGFjaG1lbnQucmVnaW9uPy50ZXh0dXJlLnRleHR1cmUsXG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmF0dGFjaG1lbnRDYWNoZURhdGFbc2xvdC5kYXRhLmluZGV4XVthdHRhY2htZW50Lm5hbWVdO1xuXHR9XG5cblx0cHJvdGVjdGVkIG9uVmlld1VwZGF0ZSAoKSB7XG5cdFx0Ly8gaW5jcmVtZW50IGZyb20gdGhlIDEydGggYml0IVxuXHRcdHRoaXMuX2RpZFZpZXdDaGFuZ2VUaWNrKys7XG5cdFx0aWYgKCF0aGlzLl9ib3VuZHNQcm92aWRlcikge1xuXHRcdFx0dGhpcy5fYm91bmRzRGlydHkgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmRpZFZpZXdVcGRhdGUpIHJldHVybjtcblx0XHR0aGlzLmRpZFZpZXdVcGRhdGUgPSB0cnVlO1xuXG5cdFx0Y29uc3QgcmVuZGVyR3JvdXAgPSB0aGlzLnJlbmRlckdyb3VwIHx8IHRoaXMucGFyZW50UmVuZGVyR3JvdXA7XG5cblx0XHRpZiAocmVuZGVyR3JvdXApIHtcblx0XHRcdHJlbmRlckdyb3VwLm9uQ2hpbGRWaWV3VXBkYXRlKHRoaXMpO1xuXHRcdH1cblxuXHRcdHRoaXMuZGVidWc/LnJlbmRlckRlYnVnKHRoaXMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEF0dGFjaGVzIGEgUGl4aUpTIGNvbnRhaW5lciB0byBhIHNwZWNpZmllZCBzbG90LiBUaGlzIHdpbGwgbWFwIHRoZSB3b3JsZCB0cmFuc2Zvcm0gb2YgdGhlIHNsb3RzIGJvbmVcblx0ICogdG8gdGhlIGF0dGFjaGVkIGNvbnRhaW5lci4gQSBjb250YWluZXIgY2FuIG9ubHkgYmUgYXR0YWNoZWQgdG8gb25lIHNsb3QgYXQgYSB0aW1lLlxuXHQgKlxuXHQgKiBAcGFyYW0gY29udGFpbmVyIC0gVGhlIGNvbnRhaW5lciB0byBhdHRhY2ggdG8gdGhlIHNsb3Rcblx0ICogQHBhcmFtIHNsb3RSZWYgLSBUaGUgc2xvdCBpZCBvciAgc2xvdCB0byBhdHRhY2ggdG9cblx0ICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBzZXR0aW5ncyBmb3IgdGhlIGF0dGFjaG1lbnQuXG5cdCAqIEBwYXJhbSBvcHRpb25zLmZvbGxvd0F0dGFjaG1lbnRUaW1lbGluZSAtIElmIHRydWUsIHRoZSBhdHRhY2htZW50IHdpbGwgZm9sbG93IHRoZSBzbG90J3MgYXR0YWNobWVudCB0aW1lbGluZS5cblx0ICovXG5cdHB1YmxpYyBhZGRTbG90T2JqZWN0IChzbG90OiBudW1iZXIgfCBzdHJpbmcgfCBTbG90LCBjb250YWluZXI6IENvbnRhaW5lciwgb3B0aW9ucz86IHsgZm9sbG93QXR0YWNobWVudFRpbWVsaW5lPzogYm9vbGVhbiB9KSB7XG5cdFx0c2xvdCA9IHRoaXMuZ2V0U2xvdEZyb21SZWYoc2xvdCk7XG5cblx0XHQvLyBuZWVkIHRvIGNoZWNrIGluIG9uIHRoZSBjb250YWluZXIgdG9vLi4uXG5cdFx0Zm9yIChjb25zdCBpIGluIHRoaXMuX3Nsb3RzT2JqZWN0KSB7XG5cdFx0XHRpZiAodGhpcy5fc2xvdHNPYmplY3RbaV0/LmNvbnRhaW5lciA9PT0gY29udGFpbmVyKSB7XG5cdFx0XHRcdHRoaXMucmVtb3ZlU2xvdE9iamVjdCh0aGlzLl9zbG90c09iamVjdFtpXS5zbG90KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLnJlbW92ZVNsb3RPYmplY3Qoc2xvdCk7XG5cblx0XHRjb250YWluZXIuaW5jbHVkZUluQnVpbGQgPSBmYWxzZTtcblxuXHRcdC8vIFRPRE8gb25seSBhZGQgb25jZT8/XG5cdFx0dGhpcy5hZGRDaGlsZChjb250YWluZXIpO1xuXG5cdFx0Y29uc3Qgc2xvdE9iamVjdCA9IHtcblx0XHRcdGNvbnRhaW5lcixcblx0XHRcdHNsb3QsXG5cdFx0XHRmb2xsb3dBdHRhY2htZW50VGltZWxpbmU6IG9wdGlvbnM/LmZvbGxvd0F0dGFjaG1lbnRUaW1lbGluZSB8fCBmYWxzZSxcblx0XHR9O1xuXHRcdHRoaXMuX3Nsb3RzT2JqZWN0W3Nsb3QuZGF0YS5uYW1lXSA9IHNsb3RPYmplY3Q7XG5cblx0XHR0aGlzLnVwZGF0ZVNsb3RPYmplY3Qoc2xvdE9iamVjdCk7XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyBhIFBpeGlKUyBjb250YWluZXIgZnJvbSB0aGUgc2xvdCBpdCBpcyBhdHRhY2hlZCB0by5cblx0ICpcblx0ICogQHBhcmFtIGNvbnRhaW5lciAtIFRoZSBjb250YWluZXIgdG8gZGV0YWNoIGZyb20gdGhlIHNsb3Rcblx0ICogQHBhcmFtIHNsb3RPckNvbnRhaW5lciAtIFRoZSBjb250YWluZXIsIHNsb3QgaWQgb3Igc2xvdCB0byBkZXRhY2ggZnJvbVxuXHQgKi9cblx0cHVibGljIHJlbW92ZVNsb3RPYmplY3QgKHNsb3RPckNvbnRhaW5lcjogbnVtYmVyIHwgc3RyaW5nIHwgU2xvdCB8IENvbnRhaW5lcikge1xuXHRcdGxldCBjb250YWluZXJUb1JlbW92ZTogQ29udGFpbmVyIHwgdW5kZWZpbmVkO1xuXG5cdFx0aWYgKHNsb3RPckNvbnRhaW5lciBpbnN0YW5jZW9mIENvbnRhaW5lcikge1xuXHRcdFx0Zm9yIChjb25zdCBpIGluIHRoaXMuX3Nsb3RzT2JqZWN0KSB7XG5cdFx0XHRcdGlmICh0aGlzLl9zbG90c09iamVjdFtpXT8uY29udGFpbmVyID09PSBzbG90T3JDb250YWluZXIpIHtcblx0XHRcdFx0XHR0aGlzLl9zbG90c09iamVjdFtpXSA9IG51bGw7XG5cblx0XHRcdFx0XHRjb250YWluZXJUb1JlbW92ZSA9IHNsb3RPckNvbnRhaW5lcjtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGNvbnN0IHNsb3QgPSB0aGlzLmdldFNsb3RGcm9tUmVmKHNsb3RPckNvbnRhaW5lcik7XG5cblx0XHRcdGNvbnRhaW5lclRvUmVtb3ZlID0gdGhpcy5fc2xvdHNPYmplY3Rbc2xvdC5kYXRhLm5hbWVdPy5jb250YWluZXI7XG5cdFx0XHR0aGlzLl9zbG90c09iamVjdFtzbG90LmRhdGEubmFtZV0gPSBudWxsO1xuXHRcdH1cblxuXHRcdGlmIChjb250YWluZXJUb1JlbW92ZSkge1xuXHRcdFx0dGhpcy5yZW1vdmVDaGlsZChjb250YWluZXJUb1JlbW92ZSk7XG5cblx0XHRcdGNvbnRhaW5lclRvUmVtb3ZlLmluY2x1ZGVJbkJ1aWxkID0gdHJ1ZTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogUmVtb3ZlcyBhbGwgUGl4aUpTIGNvbnRhaW5lcnMgYXR0YWNoZWQgdG8gYW55IHNsb3QuXG5cdCAqL1xuXHRwdWJsaWMgcmVtb3ZlU2xvdE9iamVjdHMgKCkge1xuXHRcdE9iamVjdC5lbnRyaWVzKHRoaXMuX3Nsb3RzT2JqZWN0KS5mb3JFYWNoKChbc2xvdE5hbWUsIHNsb3RPYmplY3RdKSA9PiB7XG5cdFx0XHRpZiAoc2xvdE9iamVjdCkgc2xvdE9iamVjdC5jb250YWluZXIucmVtb3ZlRnJvbVBhcmVudCgpO1xuXHRcdFx0ZGVsZXRlIHRoaXMuX3Nsb3RzT2JqZWN0W3Nsb3ROYW1lXTtcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgY29udGFpbmVyIGF0dGFjaGVkIHRvIGEgc2xvdCwgb3IgdW5kZWZpbmVkIGlmIG5vIGNvbnRhaW5lciBpcyBhdHRhY2hlZC5cblx0ICpcblx0ICogQHBhcmFtIHNsb3RSZWYgLSBUaGUgc2xvdCBpZCBvciBzbG90IHRvIGdldCB0aGUgYXR0YWNobWVudCBmcm9tXG5cdCAqIEByZXR1cm5zIC0gVGhlIGNvbnRhaW5lciBhdHRhY2hlZCB0byB0aGUgc2xvdFxuXHQgKi9cblx0cHVibGljIGdldFNsb3RPYmplY3QgKHNsb3Q6IG51bWJlciB8IHN0cmluZyB8IFNsb3QpIHtcblx0XHRzbG90ID0gdGhpcy5nZXRTbG90RnJvbVJlZihzbG90KTtcblxuXHRcdHJldHVybiB0aGlzLl9zbG90c09iamVjdFtzbG90LmRhdGEubmFtZV0/LmNvbnRhaW5lcjtcblx0fVxuXG5cdHByb3RlY3RlZCB1cGRhdGVCb3VuZHMgKCkge1xuXHRcdHRoaXMuX2JvdW5kc0RpcnR5ID0gZmFsc2U7XG5cblx0XHR0aGlzLnNrZWxldG9uQm91bmRzIHx8PSBuZXcgU2tlbGV0b25Cb3VuZHMoKTtcblxuXHRcdGNvbnN0IHNrZWxldG9uQm91bmRzID0gdGhpcy5za2VsZXRvbkJvdW5kcztcblxuXHRcdHNrZWxldG9uQm91bmRzLnVwZGF0ZSh0aGlzLnNrZWxldG9uLCB0cnVlKTtcblxuXHRcdGlmICh0aGlzLl9ib3VuZHNQcm92aWRlcikge1xuXHRcdFx0Y29uc3QgYm91bmRzU3BpbmUgPSB0aGlzLl9ib3VuZHNQcm92aWRlci5jYWxjdWxhdGVCb3VuZHModGhpcyk7XG5cblx0XHRcdGNvbnN0IGJvdW5kcyA9IHRoaXMuX2JvdW5kcztcblx0XHRcdGJvdW5kcy5jbGVhcigpO1xuXG5cdFx0XHRib3VuZHMueCA9IGJvdW5kc1NwaW5lLng7XG5cdFx0XHRib3VuZHMueSA9IGJvdW5kc1NwaW5lLnk7XG5cdFx0XHRib3VuZHMud2lkdGggPSBib3VuZHNTcGluZS53aWR0aDtcblx0XHRcdGJvdW5kcy5oZWlnaHQgPSBib3VuZHNTcGluZS5oZWlnaHQ7XG5cblx0XHR9IGVsc2UgaWYgKHNrZWxldG9uQm91bmRzLm1pblggPT09IEluZmluaXR5KSB7XG5cdFx0XHRpZiAodGhpcy5oYXNOZXZlclVwZGF0ZWQpIHtcblx0XHRcdFx0dGhpcy5fdXBkYXRlQW5kQXBwbHlTdGF0ZSgwKTtcblx0XHRcdFx0dGhpcy5fYm91bmRzRGlydHkgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3ZhbGlkYXRlQW5kVHJhbnNmb3JtQXR0YWNobWVudHMoKTtcblxuXHRcdFx0Y29uc3QgZHJhd09yZGVyID0gdGhpcy5za2VsZXRvbi5kcmF3T3JkZXI7XG5cdFx0XHRjb25zdCBib3VuZHMgPSB0aGlzLl9ib3VuZHM7XG5cblx0XHRcdGJvdW5kcy5jbGVhcigpO1xuXG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGRyYXdPcmRlci5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRjb25zdCBzbG90ID0gZHJhd09yZGVyW2ldO1xuXG5cdFx0XHRcdGNvbnN0IGF0dGFjaG1lbnQgPSBzbG90LmdldEF0dGFjaG1lbnQoKTtcblxuXHRcdFx0XHRpZiAoYXR0YWNobWVudCAmJiAoYXR0YWNobWVudCBpbnN0YW5jZW9mIFJlZ2lvbkF0dGFjaG1lbnQgfHwgYXR0YWNobWVudCBpbnN0YW5jZW9mIE1lc2hBdHRhY2htZW50KSkge1xuXHRcdFx0XHRcdGNvbnN0IGNhY2hlRGF0YSA9IHRoaXMuX2dldENhY2hlZERhdGEoc2xvdCwgYXR0YWNobWVudCk7XG5cblx0XHRcdFx0XHRib3VuZHMuYWRkVmVydGV4RGF0YShjYWNoZURhdGEudmVydGljZXMsIDAsIGNhY2hlRGF0YS52ZXJ0aWNlcy5sZW5ndGgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0dGhpcy5fYm91bmRzLm1pblggPSBza2VsZXRvbkJvdW5kcy5taW5YO1xuXHRcdFx0dGhpcy5fYm91bmRzLm1pblkgPSBza2VsZXRvbkJvdW5kcy5taW5ZO1xuXHRcdFx0dGhpcy5fYm91bmRzLm1heFggPSBza2VsZXRvbkJvdW5kcy5tYXhYO1xuXHRcdFx0dGhpcy5fYm91bmRzLm1heFkgPSBza2VsZXRvbkJvdW5kcy5tYXhZO1xuXHRcdH1cblx0fVxuXG5cdC8qKiBAaW50ZXJuYWwgKi9cblx0YWRkQm91bmRzIChib3VuZHM6IEJvdW5kcykge1xuXHRcdGJvdW5kcy5hZGRCb3VuZHModGhpcy5ib3VuZHMpO1xuXHR9XG5cblx0LyoqXG5cdCAqIERlc3Ryb3lzIHRoaXMgc3ByaXRlIHJlbmRlcmFibGUgYW5kIG9wdGlvbmFsbHkgaXRzIHRleHR1cmUuXG5cdCAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBwYXJhbWV0ZXIuIEEgYm9vbGVhbiB3aWxsIGFjdCBhcyBpZiBhbGwgb3B0aW9uc1xuXHQgKiAgaGF2ZSBiZWVuIHNldCB0byB0aGF0IHZhbHVlXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudGV4dHVyZT1mYWxzZV0gLSBTaG91bGQgaXQgZGVzdHJveSB0aGUgY3VycmVudCB0ZXh0dXJlIG9mIHRoZSByZW5kZXJhYmxlIGFzIHdlbGxcblx0ICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50ZXh0dXJlU291cmNlPWZhbHNlXSAtIFNob3VsZCBpdCBkZXN0cm95IHRoZSB0ZXh0dXJlU291cmNlIG9mIHRoZSByZW5kZXJhYmxlIGFzIHdlbGxcblx0ICovXG5cdHB1YmxpYyBvdmVycmlkZSBkZXN0cm95IChvcHRpb25zOiBEZXN0cm95T3B0aW9ucyA9IGZhbHNlKSB7XG5cdFx0c3VwZXIuZGVzdHJveShvcHRpb25zKTtcblxuXHRcdFRpY2tlci5zaGFyZWQucmVtb3ZlKHRoaXMuaW50ZXJuYWxVcGRhdGUsIHRoaXMpO1xuXHRcdHRoaXMuc3RhdGUuY2xlYXJMaXN0ZW5lcnMoKTtcblx0XHR0aGlzLmRlYnVnID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuc2tlbGV0b24gPSBudWxsIGFzIGFueTtcblx0XHR0aGlzLnN0YXRlID0gbnVsbCBhcyBhbnk7XG5cdFx0KHRoaXMuX3Nsb3RzT2JqZWN0IGFzIGFueSkgPSBudWxsO1xuXHRcdHRoaXMuX2xhc3RBdHRhY2htZW50cy5sZW5ndGggPSAwO1xuXHRcdHRoaXMuYXR0YWNobWVudENhY2hlRGF0YSA9IG51bGwgYXMgYW55O1xuXHR9XG5cblx0LyoqIENvbnZlcnRzIGEgcG9pbnQgZnJvbSB0aGUgc2tlbGV0b24gY29vcmRpbmF0ZSBzeXN0ZW0gdG8gdGhlIFBpeGkgd29ybGQgY29vcmRpbmF0ZSBzeXN0ZW0uICovXG5cdHB1YmxpYyBza2VsZXRvblRvUGl4aVdvcmxkQ29vcmRpbmF0ZXMgKHBvaW50OiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0pIHtcblx0XHR0aGlzLndvcmxkVHJhbnNmb3JtLmFwcGx5KHBvaW50LCBwb2ludCk7XG5cdH1cblxuXHQvKiogQ29udmVydHMgYSBwb2ludCBmcm9tIHRoZSBQaXhpIHdvcmxkIGNvb3JkaW5hdGUgc3lzdGVtIHRvIHRoZSBza2VsZXRvbiBjb29yZGluYXRlIHN5c3RlbS4gKi9cblx0cHVibGljIHBpeGlXb3JsZENvb3JkaW5hdGVzVG9Ta2VsZXRvbiAocG9pbnQ6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSkge1xuXHRcdHRoaXMud29ybGRUcmFuc2Zvcm0uYXBwbHlJbnZlcnNlKHBvaW50LCBwb2ludCk7XG5cdH1cblxuXHQvKiogQ29udmVydHMgYSBwb2ludCBmcm9tIHRoZSBQaXhpIHdvcmxkIGNvb3JkaW5hdGUgc3lzdGVtIHRvIHRoZSBib25lJ3MgbG9jYWwgY29vcmRpbmF0ZSBzeXN0ZW0uICovXG5cdHB1YmxpYyBwaXhpV29ybGRDb29yZGluYXRlc1RvQm9uZSAocG9pbnQ6IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfSwgYm9uZTogQm9uZSkge1xuXHRcdHRoaXMucGl4aVdvcmxkQ29vcmRpbmF0ZXNUb1NrZWxldG9uKHBvaW50KTtcblx0XHRpZiAoYm9uZS5wYXJlbnQpIHtcblx0XHRcdGJvbmUucGFyZW50LndvcmxkVG9Mb2NhbChwb2ludCBhcyBWZWN0b3IyKTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRib25lLndvcmxkVG9Mb2NhbChwb2ludCBhcyBWZWN0b3IyKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogVXNlIHRoaXMgbWV0aG9kIHRvIGluc3RhbnRpYXRlIGEgU3BpbmUgZ2FtZSBvYmplY3QuXG5cdCAqIEJlZm9yZSBpbnN0YW50aWF0aW5nIGEgU3BpbmUgZ2FtZSBvYmplY3QsIHRoZSBza2VsZXRvbiAoYC5za2VsYCBvciBgLmpzb25gKSBhbmQgdGhlIGF0bGFzIHRleHQgZmlsZXMgbXVzdCBiZSBsb2FkZWQgaW50byB0aGUgQXNzZXRzLiBGb3IgZXhhbXBsZTpcblx0ICogYGBgXG5cdCAqIFBJWEkuQXNzZXRzLmFkZChcInNhY2tEYXRhXCIsIFwiL2Fzc2V0cy9zYWNrLXByby5za2VsXCIpO1xuXHQgKiBQSVhJLkFzc2V0cy5hZGQoXCJzYWNrQXRsYXNcIiwgXCIvYXNzZXRzL3NhY2stcG1hLmF0bGFzXCIpO1xuXHQgKiBhd2FpdCBQSVhJLkFzc2V0cy5sb2FkKFtcInNhY2tEYXRhXCIsIFwic2Fja0F0bGFzXCJdKTtcblx0ICogYGBgXG5cdCAqIE9uY2UgYSBTcGluZSBnYW1lIG9iamVjdCBpcyBjcmVhdGVkLCBpdHMgc2tlbGV0b24gZGF0YSBpcyBjYWNoZWQgaW50byB7QGxpbmsgQ2FjaGV9IHVzaW5nIHRoZSBrZXk6XG5cdCAqIGAke3NrZWxldG9uQXNzZXROYW1lfS0ke2F0bGFzQXNzZXROYW1lfS0ke29wdGlvbnM/LnNjYWxlID8/IDF9YFxuXHQgKlxuXHQgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gY29uZmlndXJlIHRoZSBTcGluZSBnYW1lIG9iamVjdC4gU2VlIHtAbGluayBTcGluZUZyb21PcHRpb25zfVxuXHQgKiBAcmV0dXJucyB7U3BpbmV9IFRoZSBTcGluZSBnYW1lIG9iamVjdCBpbnN0YW50aWF0ZWRcblx0ICovXG5cdHN0YXRpYyBmcm9tICh7IHNrZWxldG9uLCBhdGxhcywgc2NhbGUgPSAxLCBkYXJrVGludCwgYXV0b1VwZGF0ZSA9IHRydWUsIGJvdW5kc1Byb3ZpZGVyIH06IFNwaW5lRnJvbU9wdGlvbnMpIHtcblx0XHRjb25zdCBjYWNoZUtleSA9IGAke3NrZWxldG9ufS0ke2F0bGFzfS0ke3NjYWxlfWA7XG5cblx0XHRpZiAoQ2FjaGUuaGFzKGNhY2hlS2V5KSkge1xuXHRcdFx0cmV0dXJuIG5ldyBTcGluZSh7XG5cdFx0XHRcdHNrZWxldG9uRGF0YTogQ2FjaGUuZ2V0PFNrZWxldG9uRGF0YT4oY2FjaGVLZXkpLFxuXHRcdFx0XHRkYXJrVGludCxcblx0XHRcdFx0YXV0b1VwZGF0ZSxcblx0XHRcdFx0Ym91bmRzUHJvdmlkZXIsXG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRjb25zdCBza2VsZXRvbkFzc2V0ID0gQXNzZXRzLmdldDxhbnkgfCBVaW50OEFycmF5Pihza2VsZXRvbik7XG5cblx0XHRjb25zdCBhdGxhc0Fzc2V0ID0gQXNzZXRzLmdldDxUZXh0dXJlQXRsYXM+KGF0bGFzKTtcblx0XHRjb25zdCBhdHRhY2htZW50TG9hZGVyID0gbmV3IEF0bGFzQXR0YWNobWVudExvYWRlcihhdGxhc0Fzc2V0KTtcblx0XHRjb25zdCBwYXJzZXIgPSBza2VsZXRvbkFzc2V0IGluc3RhbmNlb2YgVWludDhBcnJheVxuXHRcdFx0PyBuZXcgU2tlbGV0b25CaW5hcnkoYXR0YWNobWVudExvYWRlcilcblx0XHRcdDogbmV3IFNrZWxldG9uSnNvbihhdHRhY2htZW50TG9hZGVyKTtcblxuXHRcdHBhcnNlci5zY2FsZSA9IHNjYWxlO1xuXHRcdGNvbnN0IHNrZWxldG9uRGF0YSA9IHBhcnNlci5yZWFkU2tlbGV0b25EYXRhKHNrZWxldG9uQXNzZXQpO1xuXG5cdFx0Q2FjaGUuc2V0KGNhY2hlS2V5LCBza2VsZXRvbkRhdGEpO1xuXG5cdFx0cmV0dXJuIG5ldyBTcGluZSh7XG5cdFx0XHRza2VsZXRvbkRhdGEsXG5cdFx0XHRkYXJrVGludCxcblx0XHRcdGF1dG9VcGRhdGUsXG5cdFx0XHRib3VuZHNQcm92aWRlcixcblx0XHR9KTtcblx0fVxufVxuIl19